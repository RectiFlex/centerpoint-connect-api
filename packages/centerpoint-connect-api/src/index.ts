
// Generated by openapi-to-mcp-generator for centerpoint-connect-api v1.0.0
// Source OpenAPI spec: /Users/jacelander/Downloads/centerassistapi.json
// Generation date: 2025-09-19T01:58:39.204Z

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

// Import Schemas and Types from /types subpath with .js extension
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  type Tool,
  type CallToolResult,
  type CallToolRequest // Added type for the request parameter
} from "@modelcontextprotocol/sdk/types.js";

// Zod for runtime validation
import { z, ZodError } from 'zod';
// Library to convert JSON Schema to Zod schema string at runtime
import { jsonSchemaToZod } from 'json-schema-to-zod';

// Define JsonObject locally as a utility type
type JsonObject = Record<string, any>;

import axios, { type AxiosRequestConfig, type AxiosError } from 'axios';

// Import centralized authentication helper
import { resolveAuth, requireAuth, createAuthenticatedHeaders } from './auth.js';

// --- Server Configuration ---
const SERVER_NAME = "centerpoint-connect-api";
const SERVER_VERSION = "1.0.0";
const API_BASE_URL = "https://api.centerpointconnect.io/centerpoint";

// --- Server Instance ---
const server = new Server(
  {
    name: SERVER_NAME,
    version: SERVER_VERSION
  },
  {
    capabilities: {
      tools: {}
    }
  }
);

// --- Tool Definitions (for ListTools response) ---
// Corrected: Use Tool[] type
const toolsList: Tool[] = [

  // Tool: companiesGET (GET /companies)
  {
    name: "companiesGET",
    description: `Get companies`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[companies]": {
                "type": "string",
                "description": "Fields: manager,name,externalId \n\n On-Demand Fields: quotedValue,openQuotedValue,soldValue,modelFileTagCounts"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "filter[type]": {
                "type": "string"
            },
            "filter[manager]": {
                "type": "string"
            },
            "filter[salesStatus]": {
                "type": "string",
                "description": "Values: Sold, Lead, Candidate, or Client"
            },
            "filter[location]": {
                "type": "number"
            },
            "filter[zipcodeRange][zipcode]": {
                "type": "number"
            },
            "filter[zipcodeRange][range]": {
                "type": "number"
            },
            "filter[custom.customerType]": {
                "type": "string",
                "description": "Values: Admin, Company, Contractor, Corporate, Residential or Vendor"
            },
            "filter[search]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: companiesPOST (POST /companies)
  {
    name: "companiesPOST",
    description: `Create company`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[companies]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "type": {
                                        "type": "string",
                                        "enum": [
                                            "Admin",
                                            "Company",
                                            "Contractor",
                                            "Corporate",
                                            "Residential",
                                            "Vendor"
                                        ]
                                    },
                                    "salesStatus": {
                                        "type": "string",
                                        "enum": [
                                            "Lead",
                                            "Quoted",
                                            "Sold",
                                            "Dead"
                                        ]
                                    },
                                    "timezone": {
                                        "type": "string",
                                        "enum": [
                                            "America/Anchorage",
                                            "America/Chicago",
                                            "America/Denver",
                                            "America/Detroit",
                                            "America/Los_Angeles",
                                            "America/New_York",
                                            "America/Phoenix",
                                            "Pacific/Honolulu"
                                        ]
                                    },
                                    "is_billing": {
                                        "type": "boolean",
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "is_active": {
                                        "type": "boolean",
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "email": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "streetAddress": {
                                        "type": "string",
                                        "maxLength": 150
                                    },
                                    "subpremise": {
                                        "type": "string",
                                        "maxLength": 100
                                    },
                                    "locality": {
                                        "type": "string",
                                        "maxLength": 100
                                    },
                                    "county": {
                                        "type": "string",
                                        "maxLength": 100
                                    },
                                    "region": {
                                        "type": "string",
                                        "maxLength": 100
                                    },
                                    "postalCode": {
                                        "type": "string",
                                        "maxLength": 10
                                    },
                                    "country": {
                                        "type": "string",
                                        "maxLength": 2,
                                        "default": "us"
                                    },
                                    "latitude": {
                                        "type": "number",
                                        "format": "float"
                                    },
                                    "longitude": {
                                        "type": "number",
                                        "format": "float"
                                    },
                                    "placeId": {
                                        "type": "string"
                                    },
                                    "externalId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "importId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "managerId": {
                                        "type": "number"
                                    },
                                    "website": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "imageId": {
                                        "type": "number"
                                    },
                                    "closeRate": {
                                        "type": "number",
                                        "format": "float",
                                        "maximum": 1,
                                        "minimum": 0
                                    },
                                    "options": {
                                        "type": "object",
                                        "properties": {
                                            "taxLabelOverride": {
                                                "type": "string"
                                            },
                                            "billingAddress": {
                                                "type": "string"
                                            },
                                            "isCreditHold": {
                                                "type": "boolean"
                                            },
                                            "isTaxExempt": {
                                                "type": "boolean"
                                            },
                                            "serviceBillingInstructions": {
                                                "type": "string"
                                            },
                                            "serviceWorkInstructions": {
                                                "type": "string"
                                            },
                                            "laborRates": {
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "custom": {
                                        "type": "object",
                                        "properties": {
                                            "customerType": {
                                                "type": "string"
                                            },
                                            "companyphonenumber": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "required": [
                                    "name",
                                    "type",
                                    "salesStatus",
                                    "timezone"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: companies/{COMPANY_ID}GET (GET /companies/{COMPANY_ID})
  {
    name: "companies/{COMPANY_ID}GET",
    description: `Get single company`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "COMPANY_ID": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "COMPANY_ID"
        ]
    }
  },
  // Tool: companies/{COMPANY_ID}DELETE (DELETE /companies/{COMPANY_ID})
  {
    name: "companies/{COMPANY_ID}DELETE",
    description: `Delete company`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "COMPANY_ID": {
                "type": "string"
            },
        },
        "required": [
            "COMPANY_ID"
        ]
    }
  },
  // Tool: companies/{COMPANY_ID}PATCH (PATCH /companies/{COMPANY_ID})
  {
    name: "companies/{COMPANY_ID}PATCH",
    description: `Update company`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "COMPANY_ID": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "COMPANY_ID"
        ]
    }
  },
  // Tool: cost_codesGET (GET /cost_codes)
  {
    name: "cost_codesGET",
    description: `Get Cost codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: cost_codesPOST (POST /cost_codes)
  {
    name: "cost_codesPOST",
    description: `Create Cost codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "code": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "workTimeEntryType": {
                                        "type": "string",
                                        "enum": [
                                            "Travel",
                                            "Labor",
                                            "NonBillable"
                                        ]
                                    }
                                },
                                "required": [
                                    "name",
                                    "code"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "budgetType": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    }
                                }
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: cost_codes/{COST_CODE_ID}GET (GET /cost_codes/{COST_CODE_ID})
  {
    name: "cost_codes/{COST_CODE_ID}GET",
    description: `Get  Single Cost codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "COST_CODE_ID": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "COST_CODE_ID"
        ]
    }
  },
  // Tool: cost_codes/{COST_CODE_ID}DELETE (DELETE /cost_codes/{COST_CODE_ID})
  {
    name: "cost_codes/{COST_CODE_ID}DELETE",
    description: `Delete  Cost codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "COST_CODE_ID": {
                "type": "string"
            },
        },
        "required": [
            "COST_CODE_ID"
        ]
    }
  },
  // Tool: cost_codes/{COST_CODE_ID}PATCH (PATCH /cost_codes/{COST_CODE_ID})
  {
    name: "cost_codes/{COST_CODE_ID}PATCH",
    description: `Update  Cost codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "COST_CODE_ID": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "COST_CODE_ID"
        ]
    }
  },
  // Tool: employeesGET (GET /employees)
  {
    name: "employeesGET",
    description: `Get employees`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[profiles]": {
                "type": "string",
                "description": "Fields: name,externalId,email \n\n On-Demand Fields: lists,menus,adjustable_permissions"
            },
            "fields[workTimeEntries]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "filter[companyId]": {
                "type": "number"
            },
            "filter[isActive]": {
                "type": "boolean"
            },
            "filter[search]": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: employeesPOST (POST /employees)
  {
    name: "employeesPOST",
    description: `Create employee`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[profiles]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "visible": {
                                        "type": "boolean",
                                        "default": false,
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "timezone": {
                                        "type": "string"
                                    },
                                    "accountId": {
                                        "type": "number"
                                    },
                                    "companyId": {
                                        "type": "number"
                                    },
                                    "primaryContractorId": {
                                        "type": "number"
                                    },
                                    "primaryBuildingId": {
                                        "type": "number"
                                    },
                                    "externalId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "importId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "managerId": {
                                        "type": "number"
                                    },
                                    "locationId": {
                                        "type": "number"
                                    },
                                    "closeRate": {
                                        "type": "number",
                                        "format": "decimal",
                                        "minimum": 0,
                                        "maximum": 1
                                    },
                                    "options": {
                                        "type": "object",
                                        "properties": {
                                            "billingAddress": {
                                                "type": "string"
                                            },
                                            "isCreditHold": {
                                                "type": "boolean"
                                            },
                                            "isTaxExempt": {
                                                "type": "boolean"
                                            },
                                            "serviceBillingInstructions": {
                                                "type": "string"
                                            },
                                            "serviceWorkInstructions": {
                                                "type": "string"
                                            },
                                            "interactivePropertyUrl": {
                                                "type": "string"
                                            },
                                            "taxCodeIds": {
                                                "type": "array",
                                                "items": {
                                                    "type": "number"
                                                }
                                            }
                                        }
                                    },
                                    "custom": {
                                        "type": "object",
                                        "properties": {
                                            "roofSize": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "required": [
                                    "name",
                                    "visible",
                                    "timezone"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: employees/{EMPLOYEE_ID}GET (GET /employees/{EMPLOYEE_ID})
  {
    name: "employees/{EMPLOYEE_ID}GET",
    description: `Get Single employee`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "EMPLOYEE_ID": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "EMPLOYEE_ID"
        ]
    }
  },
  // Tool: employees/{EMPLOYEE_ID}DELETE (DELETE /employees/{EMPLOYEE_ID})
  {
    name: "employees/{EMPLOYEE_ID}DELETE",
    description: `Delete Purchase Orders`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "EMPLOYEE_ID": {
                "type": "string"
            },
        },
        "required": [
            "EMPLOYEE_ID"
        ]
    }
  },
  // Tool: employees/{EMPLOYEE_ID}PATCH (PATCH /employees/{EMPLOYEE_ID})
  {
    name: "employees/{EMPLOYEE_ID}PATCH",
    description: `Update employee`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "EMPLOYEE_ID": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "EMPLOYEE_ID"
        ]
    }
  },
  // Tool: invoicesGET (GET /invoices)
  {
    name: "invoicesGET",
    description: `Get invoice`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productions]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "filter[lastSentAt]": {
                "type": "string",
                "description": "Value: lastSentAt,invoiceDate"
            },
            "filter[productionDomain]": {
                "type": "string",
                "description": "Values: Service,Production"
            },
            "filter[productionWorkProfileId]": {
                "type": "number"
            },
            "filter[productionTruckId]": {
                "type": "string"
            },
            "filter[invoiceType]": {
                "type": "string",
                "description": "Values: Leak, Scope, Warranty, Inspection, Non-Billable, Rooftop Maintenance, Snow Removal"
            },
            "filter[productionAccountManager]": {
                "type": "number"
            },
            "filter[productionArchived]": {
                "type": "boolean",
                "description": "Values: false,null"
            },
            "filter[hasBeenInvoiced]": {
                "type": "boolean",
                "description": "Values: if productionDomain is 'service' then true Otherwise null"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "aggregates[subtotal][0]": {
                "type": "string"
            },
            "aggregates[amount][0]": {
                "type": "string"
            },
            "aggregates[margin][0]": {
                "type": "string"
            },
            "aggregates[cost][0]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "sort": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: invoicesPOST (POST /invoices)
  {
    name: "invoicesPOST",
    description: `Create invoice`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "productionId": {
                                        "type": "number"
                                    },
                                    "profileId": {
                                        "type": "number"
                                    },
                                    "name": {
                                        "type": "string",
                                        "maxLength": 5
                                    },
                                    "uniqueKey": {
                                        "type": "string",
                                        "maxLength": 8
                                    },
                                    "uuid": {
                                        "type": "string",
                                        "format": "uuid",
                                        "maxLength": 36
                                    },
                                    "amount": {
                                        "type": "number",
                                        "format": "decimal"
                                    },
                                    "invoiceDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "dueDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "lastSentAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "options": {
                                        "type": "object",
                                        "properties": {
                                            "view": {
                                                "type": "string"
                                            },
                                            "items": {
                                                "type": "array",
                                                "items": {
                                                    "type": "object",
                                                    "properties": {
                                                        "type": {
                                                            "type": "string"
                                                        },
                                                        "description": {
                                                            "type": "string"
                                                        },
                                                        "workQuantity": {
                                                            "type": "number"
                                                        },
                                                        "quantity": {
                                                            "type": "number"
                                                        },
                                                        "unitCost": {
                                                            "type": "number"
                                                        },
                                                        "unitPrice": {
                                                            "type": "number"
                                                        },
                                                        "units": {
                                                            "type": "string"
                                                        },
                                                        "costTotal": {
                                                            "type": "number"
                                                        },
                                                        "total": {
                                                            "type": "number"
                                                        },
                                                        "isVisible": {
                                                            "type": "boolean"
                                                        },
                                                        "isTaxable": {
                                                            "type": "boolean"
                                                        },
                                                        "workDate": {
                                                            "type": "string",
                                                            "format": "date"
                                                        }
                                                    }
                                                }
                                            },
                                            "custom": {
                                                "type": "object",
                                                "properties": {
                                                    "job": {
                                                        "type": [
                                                            "string",
                                                            "null"
                                                        ]
                                                    }
                                                }
                                            },
                                            "total": {
                                                "type": "number"
                                            },
                                            "margin": {
                                                "type": "number"
                                            },
                                            "taxable": {
                                                "type": "number"
                                            },
                                            "taxRate": {
                                                "type": "number"
                                            },
                                            "subtotal": {
                                                "type": "number"
                                            },
                                            "costTotal": {
                                                "type": "number"
                                            },
                                            "signature": {
                                                "type": "number"
                                            },
                                            "jobHours": {
                                                "type": "number"
                                            },
                                            "checkoutName": {
                                                "type": "number"
                                            },
                                            "costSubtotal": {
                                                "type": "number"
                                            },
                                            "isTaxExempt": {
                                                "type": "boolean"
                                            },
                                            "taxAmount": {
                                                "type": "number"
                                            },
                                            "billingAddress": {
                                                "type": "string"
                                            },
                                            "propertyAddress": {
                                                "type": "string"
                                            },
                                            "profit": {
                                                "type": "number"
                                            },
                                            "paymentTerms": {
                                                "type": "string"
                                            },
                                            "profitPerHour": {
                                                "type": "number"
                                            },
                                            "taxCodes": {
                                                "type": "string"
                                            },
                                            "description": {
                                                "type": "string"
                                            },
                                            "descriptionFontSize": {
                                                "type": "string"
                                            },
                                            "isTaxOverride": {
                                                "type": "boolean"
                                            },
                                            "isTaxCode": {
                                                "type": "boolean"
                                            }
                                        }
                                    },
                                    "profit": {
                                        "type": "number"
                                    },
                                    "materialTotal": {
                                        "type": "number"
                                    },
                                    "materialCostTotal": {
                                        "type": "number"
                                    },
                                    "laborTravelTotal": {
                                        "type": "number"
                                    },
                                    "laborTravelCostTotal": {
                                        "type": "number"
                                    },
                                    "otherTotal": {
                                        "type": "number"
                                    },
                                    "otherCostTotal": {
                                        "type": "number"
                                    },
                                    "paidAmount": {
                                        "type": "number"
                                    },
                                    "invoiceNumber": {
                                        "type": "string"
                                    },
                                    "previouslyInvoiced": {
                                        "type": "number"
                                    },
                                    "previouslyInvoicedRate": {
                                        "type": "number"
                                    },
                                    "invoiceRate": {
                                        "type": "number"
                                    },
                                    "taxLabelOverride": {
                                        "type": "string"
                                    }
                                },
                                "required": [
                                    "productionId"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "production": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    }
                                },
                                "required": [
                                    "production"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes",
                            "relationships"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: invoices/{INVOICE_ID}GET (GET /invoices/{INVOICE_ID})
  {
    name: "invoices/{INVOICE_ID}GET",
    description: `Get Single invoice`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "INVOICE_ID": {
                "type": "string"
            },
            "fields[transactions]": {
                "type": "string"
            },
            "fields[productionDays]": {
                "type": "string"
            },
            "fields[products]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "INVOICE_ID"
        ]
    }
  },
  // Tool: invoices/{INVOICE_ID}PATCH (PATCH /invoices/{INVOICE_ID})
  {
    name: "invoices/{INVOICE_ID}PATCH",
    description: `Update invoice`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "INVOICE_ID": {
                "type": "string"
            },
            "fields[transactions]": {
                "type": "string"
            },
            "fields[productionDays]": {
                "type": "string"
            },
            "fields[products]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "INVOICE_ID"
        ]
    }
  },
  // Tool: materialsGET (GET /materials)
  {
    name: "materialsGET",
    description: `Get Materials`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[materials]": {
                "type": "string"
            },
            "filter[isChild]": {
                "type": "boolean"
            },
            "filter[manufacturer]": {
                "type": "boolean"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: materialsPOST (POST /materials)
  {
    name: "materialsPOST",
    description: `Create Materials`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "domain": {
                                        "type": "string",
                                        "enum": [
                                            "Service",
                                            "Sales"
                                        ]
                                    },
                                    "externalId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "units": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "unitPrice": {
                                        "type": "number",
                                        "format": "float"
                                    },
                                    "description": {
                                        "type": "string"
                                    },
                                    "correction": {
                                        "type": "string"
                                    },
                                    "corrected": {
                                        "type": "string"
                                    }
                                },
                                "required": [
                                    "name"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: materials/{MATERIAL_ID}GET (GET /materials/{MATERIAL_ID})
  {
    name: "materials/{MATERIAL_ID}GET",
    description: `Get Single Materials`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "MATERIAL_ID": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "MATERIAL_ID"
        ]
    }
  },
  // Tool: materials/{MATERIAL_ID}DELETE (DELETE /materials/{MATERIAL_ID})
  {
    name: "materials/{MATERIAL_ID}DELETE",
    description: `Delete Materials`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "MATERIAL_ID": {
                "type": "string"
            },
        },
        "required": [
            "MATERIAL_ID"
        ]
    }
  },
  // Tool: materials/{MATERIAL_ID}PATCH (PATCH /materials/{MATERIAL_ID})
  {
    name: "materials/{MATERIAL_ID}PATCH",
    description: `Update Materials`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "MATERIAL_ID": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "MATERIAL_ID"
        ]
    }
  },
  // Tool: opportunitiesGET (GET /opportunities)
  {
    name: "opportunitiesGET",
    description: `**Recommended not to exceed page[size]=100 records per page.**`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productions]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[leadTypes]": {
                "type": "string"
            },
            "fields[workflowStages]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "filter[latestStageTransitionedAt]": {
                "type": "string",
                "description": "Values: latestStageTransitionedAt,leadOpenedAt,openedAt,leadQuotedAt,leadSoldAt,projectedCloseDate,salesDates"
            },
            "filter[salesProfile]": {
                "type": "string"
            },
            "filter[opportunityType]": {
                "type": "string"
            },
            "filter[isArchived]": {
                "type": "boolean",
                "description": "Values: false, true"
            },
            "filter[forecastedAt]": {
                "type": "boolean",
                "description": "Values: true, null"
            },
            "filter[status]": {
                "type": "string",
                "description": "Values: lead_opened,lead_pending,lead_quoted,lead_sold, lead_dead"
            },
            "filter[workflowStageId]": {
                "type": "string",
                "description": "Values: Finalize Repairs=4, Quote Repairs=5, Pre-Approve Replacement=6, Estimate=7, Finalize Replacement=8, Quote Replacement=9, Presentation=10, Pending=11, Accepted=12, Declined=13"
            },
            "filter[leadType]": {
                "type": "string",
                "description": "Values: 43,42"
            },
            "filter[custom.division]": {
                "type": "string"
            },
            "filter[search]": {
                "type": "string"
            },
            "filter[isOpportunity]": {
                "type": "boolean"
            },
            "reports[0]": {
                "type": "string"
            },
            "reports[1]": {
                "type": "string"
            },
            "reports[2]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: opportunitiesPOST (POST /opportunities)
  {
    name: "opportunitiesPOST",
    description: `Create opportunity`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[documents]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[primaryProposal]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "domain": {
                                        "type": "string",
                                        "enum": [
                                            "Production",
                                            "Sales",
                                            "Service"
                                        ]
                                    },
                                    "opportunityType": {
                                        "type": "string",
                                        "maxLength": 100
                                    },
                                    "type": {
                                        "type": "string",
                                        "enum": [
                                            "Dumpsters",
                                            "Metal",
                                            "New Construction",
                                            "Re-Roof",
                                            "Sales",
                                            "Service"
                                        ]
                                    },
                                    "dueDate": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "oldDueDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "dueDateHasTime": {
                                        "type": "boolean",
                                        "default": false,
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "status": {
                                        "type": "string",
                                        "enum": [
                                            "lead_pending",
                                            "lead_quoted",
                                            "lead_dead"
                                        ]
                                    },
                                    "estimateTotals": {
                                        "type": "object",
                                        "properties": {
                                            "material": {
                                                "type": "number"
                                            },
                                            "labor": {
                                                "type": "number"
                                            },
                                            "laborHours": {
                                                "type": "number"
                                            },
                                            "other": {
                                                "type": "number"
                                            },
                                            "taxable": {
                                                "type": "number"
                                            },
                                            "tax": {
                                                "type": "number"
                                            },
                                            "cost": {
                                                "type": "number"
                                            },
                                            "margin": {
                                                "type": "number"
                                            },
                                            "price": {
                                                "type": "number"
                                            }
                                        }
                                    },
                                    "workProfileId": {
                                        "type": "number"
                                    },
                                    "service_workflow": {
                                        "type": "object"
                                    },
                                    "projectedCloseDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "contractorCompanyId": {
                                        "type": "number"
                                    },
                                    "leadTypeId": {
                                        "type": "number"
                                    },
                                    "forecastedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "latestStageTransitionedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadOpenedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadPendingAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadQuotedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadSoldAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadDeadAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "workflowType": {
                                        "type": "string"
                                    },
                                    "workType": {
                                        "type": "string",
                                        "enum": [
                                            "Leak",
                                            "Scope",
                                            "Warranty",
                                            "Inspection",
                                            "Non-Billable",
                                            "Rooftop Maintenance",
                                            "Snow Removal"
                                        ]
                                    },
                                    "options": {
                                        "type": "object",
                                        "properties": {
                                            "notifications": {
                                                "type": "string",
                                                "enum": [
                                                    "On",
                                                    "Off"
                                                ]
                                            },
                                            "contractorNTE": {
                                                "type": "string"
                                            },
                                            "nte": {
                                                "type": "string"
                                            },
                                            "truckId": {
                                                "type": "string"
                                            },
                                            "attachmentId": {
                                                "type": "string"
                                            },
                                            "signatureData": {
                                                "type": "object",
                                                "properties": {
                                                    "isChecked": {
                                                        "type": "boolean"
                                                    },
                                                    "name": {
                                                        "type": "string"
                                                    },
                                                    "file": {
                                                        "type": "string"
                                                    },
                                                    "date": {
                                                        "type": "string"
                                                    },
                                                    "purchaseOrder": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "namePrefix": {
                                        "type": "string",
                                        "maxLength": 6
                                    },
                                    "nameNumber": {
                                        "type": "number",
                                        "format": "int32"
                                    },
                                    "description": {
                                        "type": "string"
                                    },
                                    "invoicePurchaseOrder": {
                                        "type": "string",
                                        "maxLength": 50
                                    },
                                    "price": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "workRate": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "startDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "estimatedStartDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "startTime": {
                                        "type": "string",
                                        "format": "time"
                                    },
                                    "endDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "archivedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "heldAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "serviceApprovedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "isApprovalRequired": {
                                        "type": "boolean",
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "cost": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "markAsScheduled": {
                                        "type": "boolean"
                                    },
                                    "multipleDays": {
                                        "type": "boolean"
                                    },
                                    "custom": {
                                        "type": "object"
                                    },
                                    "openedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "scheduledAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "startedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "completedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "invoicedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "closedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    }
                                },
                                "required": [
                                    "domain"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "billedCompany": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "property": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: opportunities/{OPPORTUNITY_ID}GET (GET /opportunities/{OPPORTUNITY_ID})
  {
    name: "opportunities/{OPPORTUNITY_ID}GET",
    description: `Get Single production`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "OPPORTUNITY_ID": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[documents]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[primaryProposal]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "OPPORTUNITY_ID"
        ]
    }
  },
  // Tool: opportunities/{OPPORTUNITY_ID}DELETE (DELETE /opportunities/{OPPORTUNITY_ID})
  {
    name: "opportunities/{OPPORTUNITY_ID}DELETE",
    description: `Delete production`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "OPPORTUNITY_ID": {
                "type": "string"
            },
        },
        "required": [
            "OPPORTUNITY_ID"
        ]
    }
  },
  // Tool: opportunities/{OPPORTUNITY_ID}PATCH (PATCH /opportunities/{OPPORTUNITY_ID})
  {
    name: "opportunities/{OPPORTUNITY_ID}PATCH",
    description: `Update opportunity`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "OPPORTUNITY_ID": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[documents]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[primaryProposal]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "OPPORTUNITY_ID"
        ]
    }
  },
  // Tool: product_templatesGET (GET /product_templates)
  {
    name: "product_templatesGET",
    description: `Get Repair Library`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "filter[domain]": {
                "type": "string",
                "description": "Values: Service, Sales"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: product_templatesPOST (POST /product_templates)
  {
    name: "product_templatesPOST",
    description: `Create Repair Library`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "domain": {
                                        "type": "string",
                                        "enum": [
                                            "Service",
                                            "Sales"
                                        ]
                                    },
                                    "externalId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "units": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "unitPrice": {
                                        "type": "number",
                                        "format": "float"
                                    },
                                    "description": {
                                        "type": "string"
                                    },
                                    "correction": {
                                        "type": "string"
                                    },
                                    "corrected": {
                                        "type": "string"
                                    }
                                },
                                "required": [
                                    "name"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: product_templates/{PRODUCT_TEMPLATE_ID}GET (GET /product_templates/{PRODUCT_TEMPLATE_ID})
  {
    name: "product_templates/{PRODUCT_TEMPLATE_ID}GET",
    description: `Get Single Repair Library`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCT_TEMPLATE_ID": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCT_TEMPLATE_ID"
        ]
    }
  },
  // Tool: product_templates/{PRODUCT_TEMPLATE_ID}DELETE (DELETE /product_templates/{PRODUCT_TEMPLATE_ID})
  {
    name: "product_templates/{PRODUCT_TEMPLATE_ID}DELETE",
    description: `Delete Repair Library`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCT_TEMPLATE_ID": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCT_TEMPLATE_ID"
        ]
    }
  },
  // Tool: product_templates/{PRODUCT_TEMPLATE_ID}PATCH (PATCH /product_templates/{PRODUCT_TEMPLATE_ID})
  {
    name: "product_templates/{PRODUCT_TEMPLATE_ID}PATCH",
    description: `Update Repair Library`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCT_TEMPLATE_ID": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "PRODUCT_TEMPLATE_ID"
        ]
    }
  },
  // Tool: production_materialsGET (GET /production_materials)
  {
    name: "production_materialsGET",
    description: `Get Material Usage`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productionMaterials]": {
                "type": "string",
                "description": "Fields: name,cost \n\n On-Demand Feilds: price"
            },
            "fields[productions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[materials]": {
                "type": "string"
            },
            "filter[createdAt][gt]": {
                "type": "string",
                "description": "Values: Today, This Week, This Month, 3 Months, This Year, Custom, All Time"
            },
            "filter[createdAt][lt]": {
                "type": "string"
            },
            "filter[createdAt][timezone]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: production_materialsPOST (POST /production_materials)
  {
    name: "production_materialsPOST",
    description: `Create Material Usage`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productionMaterials]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "quantity": {
                                        "type": "number",
                                        "format": "float"
                                    },
                                    "units": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "unit_cost": {
                                        "type": "number",
                                        "format": "float"
                                    },
                                    "cost": {
                                        "type": "number",
                                        "format": "float"
                                    }
                                },
                                "required": [
                                    "name",
                                    "quantity"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "production": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    }
                                },
                                "required": [
                                    "production"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes",
                            "relationships"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: production_materials/{PRODUCTION_MATERIAL_ID}DELETE (DELETE /production_materials/{PRODUCTION_MATERIAL_ID})
  {
    name: "production_materials/{PRODUCTION_MATERIAL_ID}DELETE",
    description: `Delete Material Usage`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_MATERIAL_ID": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCTION_MATERIAL_ID"
        ]
    }
  },
  // Tool: production_materials/{PRODUCTION_MATERIAL_ID}PATCH (PATCH /production_materials/{PRODUCTION_MATERIAL_ID})
  {
    name: "production_materials/{PRODUCTION_MATERIAL_ID}PATCH",
    description: `Update Material Usage`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_MATERIAL_ID": {
                "type": "string"
            },
            "fields[productionMaterials]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "PRODUCTION_MATERIAL_ID"
        ]
    }
  },
  // Tool: productionsGET (GET /productions)
  {
    name: "productionsGET",
    description: `**Recommended not to exceed page[size]=100 records per page.**`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productions]": {
                "type": "string",
                "description": "Fields: property,propertyCompany,billedCompany \n\n On-Demand Fields: modelFileTagCounts"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[locations]": {
                "type": "string"
            },
            "fields[subcontractorProfiles]": {
                "type": "string"
            },
            "fields[workflowStages]": {
                "type": "string"
            },
            "filter[latestStageTransitionedAt]": {
                "type": "string",
                "description": "Values:  latestStageTransitionedAt,openedAt,completedAt"
            },
            "filter[location]": {
                "type": "string"
            },
            "filter[isArchived]": {
                "type": "boolean"
            },
            "filter[domain]": {
                "type": "string"
            },
            "filter[worker]": {
                "type": "string"
            },
            "filter[status]": {
                "type": "string",
                "description": "Values: opened, scheduled, started, completed, closed"
            },
            "filter[workflowStageId]": {
                "type": "string",
                "description": "Values: New Project=23, Job # & Invoice=24, Order Materials=25, Logistics=26,   Deposit Paid=27, Scheduled=28, In Progress=29, Complete=30, Final Invoice=31, Final=32, Warranty Inspection Requested=33, Warranty Received=34, Closed=35"
            },
            "filter[search]": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: productions/{PRODUCTION_ID}GET (GET /productions/{PRODUCTION_ID})
  {
    name: "productions/{PRODUCTION_ID}GET",
    description: `Get Single production`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_ID": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[productionDays]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCTION_ID"
        ]
    }
  },
  // Tool: productions/{PRODUCTION_ID}DELETE (DELETE /productions/{PRODUCTION_ID})
  {
    name: "productions/{PRODUCTION_ID}DELETE",
    description: `Delete production`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_ID": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCTION_ID"
        ]
    }
  },
  // Tool: productions/{PRODUCTION_ID}PATCH (PATCH /productions/{PRODUCTION_ID})
  {
    name: "productions/{PRODUCTION_ID}PATCH",
    description: `Update production`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_ID": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[productionDays]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "PRODUCTION_ID"
        ]
    }
  },
  // Tool: productions/{PRODUCTION_ID}/production_materialsGET (GET /productions/{PRODUCTION_ID}/production_materials)
  {
    name: "productions/{PRODUCTION_ID}/production_materialsGET",
    description: `Get Single Materials`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_ID": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCTION_ID"
        ]
    }
  },
  // Tool: productions/{PRODUCTION_ID}/purchase_ordersGET (GET /productions/{PRODUCTION_ID}/purchase_orders)
  {
    name: "productions/{PRODUCTION_ID}/purchase_ordersGET",
    description: `Get Single Purchase Orders`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_ID": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCTION_ID"
        ]
    }
  },
  // Tool: profilesGET (GET /profiles)
  {
    name: "profilesGET",
    description: `Get contacts`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[profiles]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "filter[company.type]": {
                "type": "string",
                "description": "Values: company, corporate, vendor, residential"
            },
            "filter[company.saleStatus]": {
                "type": "string",
                "description": "Values: Lead, Sold, Quoted, Dead"
            },
            "filter[company.managerId]": {
                "type": "number"
            },
            "include": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: profilesPOST (POST /profiles)
  {
    name: "profilesPOST",
    description: `Create contact`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 50
                                    },
                                    "companyId": {
                                        "type": "number"
                                    },
                                    "userId": {
                                        "type": "number"
                                    },
                                    "userRoleId": {
                                        "type": "number"
                                    },
                                    "groupId": {
                                        "type": "number"
                                    },
                                    "externalId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "importId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "email": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "position": {
                                        "type": "string",
                                        "maxLength": 50
                                    },
                                    "office": {
                                        "type": "string",
                                        "maxLength": 12
                                    },
                                    "officeExt": {
                                        "type": "string",
                                        "maxLength": 8
                                    },
                                    "mobile": {
                                        "type": "string",
                                        "maxLength": 12
                                    },
                                    "fax": {
                                        "type": "string",
                                        "maxLength": 12
                                    },
                                    "imageId": {
                                        "type": "number"
                                    },
                                    "isActive": {
                                        "type": "boolean",
                                        "default": true,
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "allProperties": {
                                        "type": "boolean",
                                        "default": 0,
                                        "enum": [
                                            1,
                                            0
                                        ]
                                    },
                                    "isBilling": {
                                        "type": "boolean",
                                        "default": 0,
                                        "enum": [
                                            1,
                                            0
                                        ]
                                    },
                                    "options": {
                                        "type": "object",
                                        "properties": {
                                            "truckId": {
                                                "type": "string"
                                            },
                                            "laborCost": {
                                                "type": "number"
                                            },
                                            "propertyIds": {
                                                "type": "array",
                                                "items": {
                                                    "type": "number"
                                                }
                                            },
                                            "serviceNotifications": {
                                                "type": "object"
                                            },
                                            "serviceNotificationsProperty": {
                                                "type": "object"
                                            },
                                            "serviceNotificationsCompany": {
                                                "type": "object"
                                            },
                                            "serviceNotificationsTexas": {
                                                "type": "object"
                                            },
                                            "serviceNotificationsNonTexas": {
                                                "type": "object"
                                            },
                                            "serviceNotificationsCorporate": {
                                                "type": "object"
                                            },
                                            "serviceNotificationsNonCorporate": {
                                                "type": "object"
                                            },
                                            "productionNotifications": {
                                                "type": "object"
                                            },
                                            "productionNotificationsCorporate": {
                                                "type": "object"
                                            },
                                            "productionNotificationsNonCorporate": {
                                                "type": "object"
                                            },
                                            "productionNotificationsCompany": {
                                                "type": "object"
                                            },
                                            "productionNotificationsProperty": {
                                                "type": "object"
                                            },
                                            "allowedFileLibraryTags": {
                                                "type": "array",
                                                "items": {
                                                    "type": "string"
                                                }
                                            },
                                            "allowedMenuItems": {
                                                "type": "array",
                                                "items": {
                                                    "type": "string"
                                                }
                                            },
                                            "emailSignature": {
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "timezone": {
                                        "type": "string"
                                    },
                                    "lists": {
                                        "type": "object",
                                        "properties": {
                                            "accountManagers": {
                                                "type": "boolean"
                                            },
                                            "projectManagers": {
                                                "type": "boolean"
                                            },
                                            "serviceHelpers": {
                                                "type": "boolean"
                                            },
                                            "technicians": {
                                                "type": "boolean"
                                            }
                                        }
                                    },
                                    "adjustablePermissions": {
                                        "type": "object",
                                        "properties": {
                                            "timekeeping.update": {
                                                "type": "boolean"
                                            },
                                            "drawings.pricing.update": {
                                                "type": "boolean"
                                            },
                                            "account.download": {
                                                "type": "boolean"
                                            }
                                        }
                                    },
                                    "custom": {
                                        "type": "object"
                                    }
                                },
                                "required": [
                                    "name"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: profiles/{PROFILE_ID}GET (GET /profiles/{PROFILE_ID})
  {
    name: "profiles/{PROFILE_ID}GET",
    description: `Get Single contact`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PROFILE_ID": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "PROFILE_ID"
        ]
    }
  },
  // Tool: profiles/{PROFILE_ID}DELETE (DELETE /profiles/{PROFILE_ID})
  {
    name: "profiles/{PROFILE_ID}DELETE",
    description: `Delete contact`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PROFILE_ID": {
                "type": "string"
            },
        },
        "required": [
            "PROFILE_ID"
        ]
    }
  },
  // Tool: profiles/{PROFILE_ID}PATCH (PATCH /profiles/{PROFILE_ID})
  {
    name: "profiles/{PROFILE_ID}PATCH",
    description: `Update contact`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PROFILE_ID": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "PROFILE_ID"
        ]
    }
  },
  // Tool: propertiesGET (GET /properties)
  {
    name: "propertiesGET",
    description: `Get properties`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[properties]": {
                "type": "string",
                "description": "Fields: manager,company,primaryContractor \n\n On-Demand Fields: modelFileTagCounts"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[locations]": {
                "type": "string"
            },
            "filter[type]": {
                "type": "string"
            },
            "filter[location]": {
                "type": "string"
            },
            "filter[roofSize]": {
                "type": "string"
            },
            "filter[search]": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: propertiesPOST (POST /properties)
  {
    name: "propertiesPOST",
    description: `Create property`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[properties]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "visible": {
                                        "type": "boolean",
                                        "default": false,
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "timezone": {
                                        "type": "string"
                                    },
                                    "accountId": {
                                        "type": "number"
                                    },
                                    "companyId": {
                                        "type": "number"
                                    },
                                    "primaryContractorId": {
                                        "type": "number"
                                    },
                                    "primaryBuildingId": {
                                        "type": "number"
                                    },
                                    "externalId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "importId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "managerId": {
                                        "type": "number"
                                    },
                                    "locationId": {
                                        "type": "number"
                                    },
                                    "closeRate": {
                                        "type": "number",
                                        "format": "decimal",
                                        "minimum": 0,
                                        "maximum": 1
                                    },
                                    "options": {
                                        "type": "object",
                                        "properties": {
                                            "billingAddress": {
                                                "type": "string"
                                            },
                                            "isCreditHold": {
                                                "type": "boolean"
                                            },
                                            "isTaxExempt": {
                                                "type": "boolean"
                                            },
                                            "serviceBillingInstructions": {
                                                "type": "string"
                                            },
                                            "serviceWorkInstructions": {
                                                "type": "string"
                                            },
                                            "interactivePropertyUrl": {
                                                "type": "string"
                                            },
                                            "taxCodeIds": {
                                                "type": "array",
                                                "items": {
                                                    "type": "number"
                                                }
                                            }
                                        }
                                    },
                                    "custom": {
                                        "type": "object",
                                        "properties": {
                                            "roofSize": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "required": [
                                    "name",
                                    "visible",
                                    "timezone"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: properties/{PROPERTY_ID}GET (GET /properties/{PROPERTY_ID})
  {
    name: "properties/{PROPERTY_ID}GET",
    description: `Get Single property`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PROPERTY_ID": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "PROPERTY_ID"
        ]
    }
  },
  // Tool: properties/{PROPERTY_ID}DELETE (DELETE /properties/{PROPERTY_ID})
  {
    name: "properties/{PROPERTY_ID}DELETE",
    description: `Delete property`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PROPERTY_ID": {
                "type": "string"
            },
        },
        "required": [
            "PROPERTY_ID"
        ]
    }
  },
  // Tool: properties/{PROPERTY_ID}PATCH (PATCH /properties/{PROPERTY_ID})
  {
    name: "properties/{PROPERTY_ID}PATCH",
    description: `Update property`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PROPERTY_ID": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "PROPERTY_ID"
        ]
    }
  },
  // Tool: purchase_ordersGET (GET /purchase_orders)
  {
    name: "purchase_ordersGET",
    description: `Get Purchase Orders`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "filter[productionDomain]": {
                "type": "string",
                "description": "Values: Service, Production"
            },
            "filter[workDate][gt]": {
                "type": "string"
            },
            "filter[workDate][lt]": {
                "type": "string"
            },
            "filter[workDate][timezone]": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: purchase_ordersPOST (POST /purchase_orders)
  {
    name: "purchase_ordersPOST",
    description: `Create Purchase Orders`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "workDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "price": {
                                        "type": "number",
                                        "format": "float"
                                    },
                                    "externalId": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "description": {
                                        "type": "string"
                                    },
                                    "approvedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    }
                                },
                                "required": [
                                    "workDate",
                                    "price",
                                    "externalId"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "production": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "budget": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    }
                                }
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: purchase_orders/{PURCHASE_ORDER_ID}DELETE (DELETE /purchase_orders/{PURCHASE_ORDER_ID})
  {
    name: "purchase_orders/{PURCHASE_ORDER_ID}DELETE",
    description: `Delete Purchase Orders`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PURCHASE_ORDER_ID": {
                "type": "string"
            },
        },
        "required": [
            "PURCHASE_ORDER_ID"
        ]
    }
  },
  // Tool: purchase_orders/{PURCHASE_ORDER_ID}PATCH (PATCH /purchase_orders/{PURCHASE_ORDER_ID})
  {
    name: "purchase_orders/{PURCHASE_ORDER_ID}PATCH",
    description: `Update Purchase Orders`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PURCHASE_ORDER_ID": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "PURCHASE_ORDER_ID"
        ]
    }
  },
  // Tool: servicesGET (GET /services)
  {
    name: "servicesGET",
    description: `**Recommended not to exceed page[size]=100 records per page.**`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productions]": {
                "type": "string",
                "description": "Fields: property,propertyCompany,billedCompany \n\n On-Demand Fields: total_change_order,total_approved_change_order,estimated_cost"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[locations]": {
                "type": "string"
            },
            "fields[subcontractorProfiles]": {
                "type": "string"
            },
            "fields[workflowStages]": {
                "type": "string"
            },
            "filter[latestStageTransitionedAt]": {
                "type": "string",
                "description": "Values:  latestStageTransitionedAt,openedAt,completedAt,invoicedAt,createdAt"
            },
            "filter[isArchived]": {
                "type": "boolean",
                "description": "Values: false,null"
            },
            "filter[domain]": {
                "type": "string"
            },
            "filter[isHeld]": {
                "type": "string",
                "description": "Values: true,null"
            },
            "filter[workflowStageId]": {
                "type": "string",
                "description": "Values: New Service=14,Accepted=15,Scheduled=16,En Route=17,In Progress=18,Completed=19,Authorized=20,Invoiced=21,Closed=22"
            },
            "filter[workType]": {
                "type": "string",
                "description": "Values: Leak,Scope,Warranty,Inspection,Non-Billable,Rooftop Maintenance,Snow Removal"
            },
            "filter[managerId]": {
                "type": "string"
            },
            "filter[worker]": {
                "type": "string"
            },
            "filter[location]": {
                "type": "string"
            },
            "filter[custom.division]": {
                "type": "string"
            },
            "filter[search]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: servicesPOST (POST /services)
  {
    name: "servicesPOST",
    description: `Create service`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[invoices]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "fields[relatedProductions]": {
                "type": "string"
            },
            "fields[productTemplateTags]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "domain": {
                                        "type": "string",
                                        "enum": [
                                            "Production",
                                            "Sales",
                                            "Service"
                                        ]
                                    },
                                    "opportunityType": {
                                        "type": "string",
                                        "maxLength": 100
                                    },
                                    "type": {
                                        "type": "string",
                                        "enum": [
                                            "Dumpsters",
                                            "Metal",
                                            "New Construction",
                                            "Re-Roof",
                                            "Sales",
                                            "Service"
                                        ]
                                    },
                                    "dueDate": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "oldDueDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "dueDateHasTime": {
                                        "type": "boolean",
                                        "default": false,
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "status": {
                                        "type": "string",
                                        "enum": [
                                            "lead_pending",
                                            "lead_quoted",
                                            "lead_dead"
                                        ]
                                    },
                                    "estimateTotals": {
                                        "type": "object",
                                        "properties": {
                                            "material": {
                                                "type": "number"
                                            },
                                            "labor": {
                                                "type": "number"
                                            },
                                            "laborHours": {
                                                "type": "number"
                                            },
                                            "other": {
                                                "type": "number"
                                            },
                                            "taxable": {
                                                "type": "number"
                                            },
                                            "tax": {
                                                "type": "number"
                                            },
                                            "cost": {
                                                "type": "number"
                                            },
                                            "margin": {
                                                "type": "number"
                                            },
                                            "price": {
                                                "type": "number"
                                            }
                                        }
                                    },
                                    "workProfileId": {
                                        "type": "number"
                                    },
                                    "service_workflow": {
                                        "type": "object"
                                    },
                                    "projectedCloseDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "contractorCompanyId": {
                                        "type": "number"
                                    },
                                    "leadTypeId": {
                                        "type": "number"
                                    },
                                    "forecastedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "latestStageTransitionedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadOpenedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadPendingAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadQuotedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadSoldAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "leadDeadAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "workflowType": {
                                        "type": "string"
                                    },
                                    "workType": {
                                        "type": "string",
                                        "enum": [
                                            "Leak",
                                            "Scope",
                                            "Warranty",
                                            "Inspection",
                                            "Non-Billable",
                                            "Rooftop Maintenance",
                                            "Snow Removal"
                                        ]
                                    },
                                    "options": {
                                        "type": "object",
                                        "properties": {
                                            "notifications": {
                                                "type": "string",
                                                "enum": [
                                                    "On",
                                                    "Off"
                                                ]
                                            },
                                            "contractorNTE": {
                                                "type": "string"
                                            },
                                            "nte": {
                                                "type": "string"
                                            },
                                            "truckId": {
                                                "type": "string"
                                            },
                                            "attachmentId": {
                                                "type": "string"
                                            },
                                            "signatureData": {
                                                "type": "object",
                                                "properties": {
                                                    "isChecked": {
                                                        "type": "boolean"
                                                    },
                                                    "name": {
                                                        "type": "string"
                                                    },
                                                    "file": {
                                                        "type": "string"
                                                    },
                                                    "date": {
                                                        "type": "string"
                                                    },
                                                    "purchaseOrder": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "namePrefix": {
                                        "type": "string",
                                        "maxLength": 6
                                    },
                                    "nameNumber": {
                                        "type": "number",
                                        "format": "int32"
                                    },
                                    "description": {
                                        "type": "string"
                                    },
                                    "invoicePurchaseOrder": {
                                        "type": "string",
                                        "maxLength": 50
                                    },
                                    "price": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "workRate": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "startDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "estimatedStartDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "startTime": {
                                        "type": "string",
                                        "format": "time"
                                    },
                                    "endDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "archivedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "heldAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "serviceApprovedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "isApprovalRequired": {
                                        "type": "boolean",
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "cost": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "markAsScheduled": {
                                        "type": "boolean"
                                    },
                                    "multipleDays": {
                                        "type": "boolean"
                                    },
                                    "custom": {
                                        "type": "object"
                                    },
                                    "openedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "scheduledAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "startedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "completedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "invoicedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "closedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    }
                                },
                                "required": [
                                    "domain"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "billedCompany": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "property": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: services/{SERVICE_ID}GET (GET /services/{SERVICE_ID})
  {
    name: "services/{SERVICE_ID}GET",
    description: `Get Single service`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "SERVICE_ID": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[documents]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[primaryProposal]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "SERVICE_ID"
        ]
    }
  },
  // Tool: services/{SERVICE_ID}DELETE (DELETE /services/{SERVICE_ID})
  {
    name: "services/{SERVICE_ID}DELETE",
    description: `Delete service`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "SERVICE_ID": {
                "type": "string"
            },
        },
        "required": [
            "SERVICE_ID"
        ]
    }
  },
  // Tool: services/{SERVICE_ID}PATCH (PATCH /services/{SERVICE_ID})
  {
    name: "services/{SERVICE_ID}PATCH",
    description: `Update service`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "SERVICE_ID": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[invoices]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "fields[relatedProductions]": {
                "type": "string"
            },
            "fields[productTemplateTags]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "SERVICE_ID"
        ]
    }
  },
  // Tool: tax_codesGET (GET /tax_codes)
  {
    name: "tax_codesGET",
    description: `Get Tax Codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: tax_codesPOST (POST /tax_codes)
  {
    name: "tax_codesPOST",
    description: `Create Tax Codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "title": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "code": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "percent": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999.999,
                                        "default": 0
                                    }
                                },
                                "required": [
                                    "title",
                                    "code"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: tax_codes/{TAX_CODE_ID}GET (GET /tax_codes/{TAX_CODE_ID})
  {
    name: "tax_codes/{TAX_CODE_ID}GET",
    description: `Get Single Tax Codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "TAX_CODE_ID": {
                "type": "string"
            },
        },
        "required": [
            "TAX_CODE_ID"
        ]
    }
  },
  // Tool: tax_codes/{TAX_CODE_ID}DELETE (DELETE /tax_codes/{TAX_CODE_ID})
  {
    name: "tax_codes/{TAX_CODE_ID}DELETE",
    description: `Delete Tax Codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "TAX_CODE_ID": {
                "type": "string"
            },
        },
        "required": [
            "TAX_CODE_ID"
        ]
    }
  },
  // Tool: tax_codes/{TAX_CODE_ID}PATCH (PATCH /tax_codes/{TAX_CODE_ID})
  {
    name: "tax_codes/{TAX_CODE_ID}PATCH",
    description: `Update Tax Codes`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "TAX_CODE_ID": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "TAX_CODE_ID"
        ]
    }
  },
  // Tool: work_time_entriesGET (GET /work_time_entries)
  {
    name: "work_time_entriesGET",
    description: `Get timekeeping`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[workTimeEntries]": {
                "type": "string",
                "description": "Feilds: lunchBreakMinutes,inAt,outAt  \n\n On-Demand Fields: active_hours"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "filter[inAt][gt]": {
                "type": "string"
            },
            "filter[inAt][lt]": {
                "type": "string"
            },
            "filter[inAt][timezone]": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "filter[isTimekeeping]": {
                "type": "boolean"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: work_time_entriesPOST (POST /work_time_entries)
  {
    name: "work_time_entriesPOST",
    description: `Create timekeeping`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: work_time_entries/{WORK_TIME_ENTRIES_ID}GET (GET /work_time_entries/{WORK_TIME_ENTRIES_ID})
  {
    name: "work_time_entries/{WORK_TIME_ENTRIES_ID}GET",
    description: `Get Single timekeeping`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "WORK_TIME_ENTRIES_ID": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "WORK_TIME_ENTRIES_ID"
        ]
    }
  },
  // Tool: work_time_entries/{WORK_TIME_ENTRIES_ID}DELETE (DELETE /work_time_entries/{WORK_TIME_ENTRIES_ID})
  {
    name: "work_time_entries/{WORK_TIME_ENTRIES_ID}DELETE",
    description: `Delete timekeeping`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "WORK_TIME_ENTRIES_ID": {
                "type": "string"
            },
        },
        "required": [
            "WORK_TIME_ENTRIES_ID"
        ]
    }
  },
  // Tool: work_time_entries/{WORK_TIME_ENTRIES_ID}PATCH (PATCH /work_time_entries/{WORK_TIME_ENTRIES_ID})
  {
    name: "work_time_entries/{WORK_TIME_ENTRIES_ID}PATCH",
    description: `Update timekeeping`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "WORK_TIME_ENTRIES_ID": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "WORK_TIME_ENTRIES_ID"
        ]
    }
  },
  // Tool: tasksGET (GET /tasks)
  {
    name: "tasksGET",
    description: `Get tasks`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[tasks]": {
                "type": "string",
                "description": "Fields: fromCompany, fromProfile, toCompany"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "filter[dueDate][gt]": {
                "type": "string"
            },
            "filter[dueDate][lt]": {
                "type": "string"
            },
            "filter[dueDate][timezone]": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "filter[internalProfileId]": {
                "type": "string"
            },
            "filter[isCompleted]": {
                "type": "boolean"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: tasksPOST (POST /tasks)
  {
    name: "tasksPOST",
    description: `Create task`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "event": {
                                        "type": "string",
                                        "maxLength": 25,
                                        "enum": [
                                            "To Do",
                                            "Call",
                                            "Drop",
                                            "Meeting",
                                            "Inspection",
                                            "Measure",
                                            "Repair Bid",
                                            "Property Approval"
                                        ]
                                    },
                                    "dueDate": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "description": {
                                        "type": "string"
                                    },
                                    "duration": {
                                        "type": "number",
                                        "minimum": 0
                                    },
                                    "completedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "completeNotes": {
                                        "type": "string"
                                    }
                                },
                                "required": [
                                    "event",
                                    "dueDate"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "fromProfile": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "toCompany": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "toProfile": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "property": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "attendees": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "array",
                                                "items": {
                                                    "type": "object",
                                                    "properties": {
                                                        "id": {
                                                            "type": "string"
                                                        },
                                                        "type": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "required": [
                                    "fromProfile"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes",
                            "relationships"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: tasks/{TASK_ID}GET (GET /tasks/{TASK_ID})
  {
    name: "tasks/{TASK_ID}GET",
    description: `Get single task`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "TASK_ID": {
                "type": "number"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "TASK_ID"
        ]
    }
  },
  // Tool: tasks/{TASK_ID}PATCH (PATCH /tasks/{TASK_ID})
  {
    name: "tasks/{TASK_ID}PATCH",
    description: `Update task`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "TASK_ID": {
                "type": "number"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[productions]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "TASK_ID"
        ]
    }
  },
  // Tool: production_daysGET (GET /production_days)
  {
    name: "production_daysGET",
    description: `Get production days`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productions]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "filter[workDate][gt]": {
                "type": "string"
            },
            "filter[workDate][lt]": {
                "type": "string"
            },
            "filter[workDate][timezone]": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: production_daysPOST (POST /production_days)
  {
    name: "production_daysPOST",
    description: `Create production days`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[productions]": {
                "type": "string"
            },
            "fields[divisions]": {
                "type": "string"
            },
            "fields[assignedProductionTaskCategories]": {
                "type": "string"
            },
            "fields[productionDays]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "workDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "measurement": {
                                        "type": "number"
                                    },
                                    "isVisible": {
                                        "type": "boolean",
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "options": {
                                        "type": "object",
                                        "properties": {
                                            "notes": {
                                                "type": "string"
                                            },
                                            "sendNow": {
                                                "type": "boolean"
                                            },
                                            "beforePhotos": {
                                                "type": "array",
                                                "items": {
                                                    "type": "object",
                                                    "properties": {
                                                        "fileId": {
                                                            "type": "number"
                                                        },
                                                        "url": {
                                                            "type": "string"
                                                        },
                                                        "thumbnailUrl": {
                                                            "type": "string"
                                                        },
                                                        "title": {
                                                            "type": "string"
                                                        },
                                                        "width": {
                                                            "type": "number"
                                                        },
                                                        "height": {
                                                            "type": "number"
                                                        },
                                                        "createdAt": {
                                                            "type": "string",
                                                            "format": "date-time"
                                                        }
                                                    }
                                                }
                                            },
                                            "afterPhotos": {
                                                "type": "array",
                                                "items": {
                                                    "type": "object",
                                                    "properties": {
                                                        "fileId": {
                                                            "type": "number"
                                                        },
                                                        "url": {
                                                            "type": "string"
                                                        },
                                                        "thumbnailUrl": {
                                                            "type": "string"
                                                        },
                                                        "title": {
                                                            "type": "string"
                                                        },
                                                        "width": {
                                                            "type": "number"
                                                        },
                                                        "height": {
                                                            "type": "number"
                                                        },
                                                        "createdAt": {
                                                            "type": "string",
                                                            "format": "date-time"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "custom": {
                                        "type": "object"
                                    }
                                },
                                "required": [
                                    "workDate",
                                    "measurement"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "production": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "divisions": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "array",
                                                "items": {
                                                    "type": "object",
                                                    "properties": {
                                                        "id": {
                                                            "type": "string"
                                                        },
                                                        "type": {
                                                            "type": "string"
                                                        }
                                                    },
                                                    "required": [
                                                        "id",
                                                        "type"
                                                    ]
                                                }
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    }
                                },
                                "required": [
                                    "production"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes",
                            "relationships"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: production_days/{PRODUCTION_DAYS_ID}GET (GET /production_days/{PRODUCTION_DAYS_ID})
  {
    name: "production_days/{PRODUCTION_DAYS_ID}GET",
    description: `Get single production days`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_DAYS_ID": {
                "type": "number"
            },
            "fields[productions]": {
                "type": "string"
            },
            "fields[divisions]": {
                "type": "string"
            },
            "fields[assignedProductionTaskCategories]": {
                "type": "string"
            },
            "fields[productionDays]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCTION_DAYS_ID"
        ]
    }
  },
  // Tool: production_days/{PRODUCTION_DAYS_ID}PATCH (PATCH /production_days/{PRODUCTION_DAYS_ID})
  {
    name: "production_days/{PRODUCTION_DAYS_ID}PATCH",
    description: `Update production days`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_DAYS_ID": {
                "type": "number"
            },
            "fields[productions]": {
                "type": "string"
            },
            "fields[divisions]": {
                "type": "string"
            },
            "fields[assignedProductionTaskCategories]": {
                "type": "string"
            },
            "fields[productionDays]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "PRODUCTION_DAYS_ID"
        ]
    }
  },
  // Tool: production_itemsGET (GET /production_items)
  {
    name: "production_itemsGET",
    description: `Get production items`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "filter[production]": {
                "type": "number"
            },
            "filter[productionOnly]": {
                "type": "boolean"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "reports[0]": {
                "type": "string"
            },
            "reports[1]": {
                "type": "string"
            },
            "reports[2]": {
                "type": "string"
            },
            "reports[3]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: production_itemsPOST (POST /production_items)
  {
    name: "production_itemsPOST",
    description: `Create production items`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "type": {
                                        "type": "string",
                                        "maxLength": 10
                                    },
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "quantity": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "units": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "unitCost": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "cost": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "isTaxable": {
                                        "type": "boolean",
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    },
                                    "isGenerated": {
                                        "type": "boolean",
                                        "enum": [
                                            true,
                                            false
                                        ]
                                    }
                                }
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "material": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "production": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "costCode": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    }
                                }
                            }
                        },
                        "required": [
                            "type"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: production_items/{PRODUCTION_ITEM_ID}GET (GET /production_items/{PRODUCTION_ITEM_ID})
  {
    name: "production_items/{PRODUCTION_ITEM_ID}GET",
    description: `Get single production items`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_ITEM_ID": {
                "type": "number"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCTION_ITEM_ID"
        ]
    }
  },
  // Tool: production_items/{PRODUCTION_ITEM_ID}PATCH (PATCH /production_items/{PRODUCTION_ITEM_ID})
  {
    name: "production_items/{PRODUCTION_ITEM_ID}PATCH",
    description: `Update production items`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCTION_ITEM_ID": {
                "type": "number"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "PRODUCTION_ITEM_ID"
        ]
    }
  },
  // Tool: budget_typesGET (GET /budget_types)
  {
    name: "budget_typesGET",
    description: `Get budget type`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: budget_typesPOST (POST /budget_types)
  {
    name: "budget_typesPOST",
    description: `Create budget type`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "code": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "color": {
                                        "type": "string",
                                        "maxLength": 255
                                    }
                                },
                                "required": [
                                    "name",
                                    "code"
                                ]
                            },
                            "relationships": {
                                "type": "object"
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: budget_types/{BUDGET_TYPE_ID}GET (GET /budget_types/{BUDGET_TYPE_ID})
  {
    name: "budget_types/{BUDGET_TYPE_ID}GET",
    description: `Get single budget type`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUDGET_TYPE_ID": {
                "type": "number"
            },
        },
        "required": [
            "BUDGET_TYPE_ID"
        ]
    }
  },
  // Tool: budget_types/{BUDGET_TYPE_ID}PATCH (PATCH /budget_types/{BUDGET_TYPE_ID})
  {
    name: "budget_types/{BUDGET_TYPE_ID}PATCH",
    description: `Update budget type`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUDGET_TYPE_ID": {
                "type": "number"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "BUDGET_TYPE_ID"
        ]
    }
  },
  // Tool: budgetGET (GET /budget)
  {
    name: "budgetGET",
    description: `Get budget`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "filter[productionId]": {
                "type": "number"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: service_agreementsGET (GET /service_agreements)
  {
    name: "service_agreementsGET",
    description: `Get service agreements`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[properties]": {
                "type": "string"
            },
            "fields[buildings]": {
                "type": "string"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "filter[isTerminated]": {
                "type": "boolean",
                "description": "Values: false,null"
            },
            "filter[nextInspectionDate][gt]": {
                "type": "string"
            },
            "filter[nextInspectionDate][lt]": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "filter[search]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: service_agreementsPOST (POST /service_agreements)
  {
    name: "service_agreementsPOST",
    description: `Create service agreements`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "startDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "frequency": {
                                        "type": "string",
                                        "enum": [
                                            "monthly",
                                            "biannually",
                                            "quarterly",
                                            "annually",
                                            "tri-annual"
                                        ]
                                    },
                                    "price": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "nextInspectionDate": {
                                        "type": "string"
                                    },
                                    "terminatedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "note": {
                                        "type": "string"
                                    },
                                    "custom": {
                                        "type": "object"
                                    }
                                },
                                "required": [
                                    "startDate",
                                    "name",
                                    "frequency"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "company": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "property": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "profile": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "file": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "required": [
                                    "company",
                                    "property"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes",
                            "relationships"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: service_agreements/{SERVICE_AGREEMENT_ID}GET (GET /service_agreements/{SERVICE_AGREEMENT_ID})
  {
    name: "service_agreements/{SERVICE_AGREEMENT_ID}GET",
    description: `Get single service agreements`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "SERVICE_AGREEMENT_ID": {
                "type": "number"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "SERVICE_AGREEMENT_ID"
        ]
    }
  },
  // Tool: service_agreements/{SERVICE_AGREEMENT_ID}PATCH (PATCH /service_agreements/{SERVICE_AGREEMENT_ID})
  {
    name: "service_agreements/{SERVICE_AGREEMENT_ID}PATCH",
    description: `Update service agreements`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "SERVICE_AGREEMENT_ID": {
                "type": "number"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "SERVICE_AGREEMENT_ID"
        ]
    }
  },
  // Tool: productsGET (GET /products)
  {
    name: "productsGET",
    description: `Get products`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[production]": {
                "type": "string"
            },
            "fields[files]": {
                "type": "string"
            },
            "fields[products]": {
                "type": "string"
            },
            "filter[productionId]": {
                "type": "number"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: productsPOST (POST /products)
  {
    name: "productsPOST",
    description: `Create products`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[products]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "beforePhotos": {
                                        "type": "array"
                                    },
                                    "afterPhotos": {
                                        "type": "array"
                                    },
                                    "staticMapUrl": {
                                        "type": "string"
                                    },
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "units": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "unitPrice": {
                                        "type": "number"
                                    },
                                    "quantity": {
                                        "type": "number"
                                    },
                                    "price": {
                                        "type": "number"
                                    },
                                    "description": {
                                        "type": "string"
                                    },
                                    "correction": {
                                        "type": "string"
                                    },
                                    "corrected": {
                                        "type": "string"
                                    },
                                    "priority": {
                                        "type": "number",
                                        "maximum": 1
                                    },
                                    "locations": {
                                        "type": "object"
                                    },
                                    "completedAt": {
                                        "type": "string",
                                        "format": "date"
                                    }
                                },
                                "required": [
                                    "name"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "buildingDivision": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object"
                                            }
                                        }
                                    },
                                    "file": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object"
                                            }
                                        }
                                    },
                                    "template": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: products/{PRODUCT_ID}GET (GET /products/{PRODUCT_ID})
  {
    name: "products/{PRODUCT_ID}GET",
    description: `Get single service repairs`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCT_ID": {
                "type": "number"
            },
            "fields[productions]": {
                "type": "string"
            },
            "fields[products]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "PRODUCT_ID"
        ]
    }
  },
  // Tool: products/{PRODUCT_ID}PATCH (PATCH /products/{PRODUCT_ID})
  {
    name: "products/{PRODUCT_ID}PATCH",
    description: `Update service repairs`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "PRODUCT_ID": {
                "type": "number"
            },
            "fields[products]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "PRODUCT_ID"
        ]
    }
  },
  // Tool: warrantiesGET (GET /warranties)
  {
    name: "warrantiesGET",
    description: `Get warranties`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "filter[start_date][gt]": {
                "type": "string",
                "description": "Values: Today, This Week, This Month, 3 Months, This Year, Custom, All Time"
            },
            "filter[start_date][lt]": {
                "type": "string"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "filter[status][0]": {
                "type": "string",
                "description": "Values: active, expired"
            },
            "filter[contractorCompanyId]": {
                "type": "number"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: warrantiesPOST (POST /warranties)
  {
    name: "warrantiesPOST",
    description: `Create warranties`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "startDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "endDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "years": {
                                        "type": "number",
                                        "maximum": 12
                                    },
                                    "manufacturer": {
                                        "type": "string",
                                        "maxLength": 255
                                    }
                                },
                                "required": [
                                    "name",
                                    "startDate",
                                    "endDate",
                                    "years"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "property": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "company": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "contractorCompany": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "file": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "required": [
                                    "property",
                                    "company"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes",
                            "relationships"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: warranties/{WARRANTY_ID}GET (GET /warranties/{WARRANTY_ID})
  {
    name: "warranties/{WARRANTY_ID}GET",
    description: `Get single warranties`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "WARRANTY_ID": {
                "type": "number"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "WARRANTY_ID"
        ]
    }
  },
  // Tool: warranties/{WARRANTY_ID}PATCH (PATCH /warranties/{WARRANTY_ID})
  {
    name: "warranties/{WARRANTY_ID}PATCH",
    description: `Update warranties`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "WARRANTY_ID": {
                "type": "number"
            },
            "fields[companies]": {
                "type": "string"
            },
            "fields[properties]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "WARRANTY_ID"
        ]
    }
  },
  // Tool: buildings/{BUILDING_ID}GET (GET /buildings/{BUILDING_ID})
  {
    name: "buildings/{BUILDING_ID}GET",
    description: `Get single building`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUILDING_ID": {
                "type": "number"
            },
            "fields[properties]": {
                "type": "string"
            },
            "fields[buildings]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "BUILDING_ID"
        ]
    }
  },
  // Tool: building_outlinesPOST (POST /building_outlines)
  {
    name: "building_outlinesPOST",
    description: `Create building outlines`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "label": {
                                        "type": "string"
                                    },
                                    "outline": {
                                        "type": "object",
                                        "properties": {
                                            "center": {
                                                "type": "string"
                                            },
                                            "zoom": {
                                                "type": "string"
                                            },
                                            "paths": {
                                                "type": "string"
                                            },
                                            "label": {
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "aerialId": {
                                        "type": "number"
                                    }
                                },
                                "required": [
                                    "outline"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "building": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "buildingDivision": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    }
                                }
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: building_outlines/{BUILDING_OUTLINES_ID}GET (GET /building_outlines/{BUILDING_OUTLINES_ID})
  {
    name: "building_outlines/{BUILDING_OUTLINES_ID}GET",
    description: `Get single building outlines`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUILDING_OUTLINES_ID": {
                "type": "number"
            },
        },
        "required": [
            "BUILDING_OUTLINES_ID"
        ]
    }
  },
  // Tool: building_outlines/{BUILDING_OUTLINES_ID}PATCH (PATCH /building_outlines/{BUILDING_OUTLINES_ID})
  {
    name: "building_outlines/{BUILDING_OUTLINES_ID}PATCH",
    description: `Update building outlines`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUILDING_OUTLINES_ID": {
                "type": "number"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "BUILDING_OUTLINES_ID"
        ]
    }
  },
  // Tool: building_divisionsPOST (POST /building_divisions)
  {
    name: "building_divisionsPOST",
    description: `Create building divisions`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "measurement": {
                                        "type": "number"
                                    },
                                    "pitchRise": {
                                        "type": "number"
                                    },
                                    "averageWallHeight": {
                                        "type": "number"
                                    },
                                    "score": {
                                        "type": "number",
                                        "maximum": 127
                                    },
                                    "installYear": {
                                        "type": "number"
                                    },
                                    "replaceYear": {
                                        "type": "number"
                                    },
                                    "replaceUnitPrice": {
                                        "type": "number",
                                        "maximum": 999
                                    },
                                    "replacePrice": {
                                        "type": "number"
                                    },
                                    "recommendation": {
                                        "type": "string"
                                    },
                                    "budgetImportance": {
                                        "type": "number"
                                    },
                                    "replacementBudgetedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    }
                                },
                                "required": [
                                    "name"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "productTemplateTag": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "outlines": {
                                        "type": "array",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "id": {
                                                    "type": "string"
                                                },
                                                "type": {
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: building_divisions/{BUILDING_DIVISIONS_ID}GET (GET /building_divisions/{BUILDING_DIVISIONS_ID})
  {
    name: "building_divisions/{BUILDING_DIVISIONS_ID}GET",
    description: `Get single building divisions`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUILDING_DIVISIONS_ID": {
                "type": "number"
            },
            "fields[products]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "BUILDING_DIVISIONS_ID"
        ]
    }
  },
  // Tool: building_divisions/{BUILDING_DIVISIONS_ID}PATCH (PATCH /building_divisions/{BUILDING_DIVISIONS_ID})
  {
    name: "building_divisions/{BUILDING_DIVISIONS_ID}PATCH",
    description: `Update building divisions`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUILDING_DIVISIONS_ID": {
                "type": "number"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "BUILDING_DIVISIONS_ID"
        ]
    }
  },
  // Tool: product_template_tagsGET (GET /product_template_tags)
  {
    name: "product_template_tagsGET",
    description: `Get product template tags`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: building_photosPOST (POST /building_photos)
  {
    name: "building_photosPOST",
    description: `Create building photos`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "type": {
                                        "type": "string",
                                        "enum": [
                                            "corner",
                                            "testcut",
                                            "general",
                                            "video",
                                            "pulltest"
                                        ]
                                    },
                                    "name": {
                                        "type": "string",
                                        "maxLength": 255
                                    },
                                    "description": {
                                        "type": "string"
                                    },
                                    "latitude": {
                                        "type": "number",
                                        "format": "decimal"
                                    },
                                    "longitude": {
                                        "type": "number",
                                        "format": "decimal"
                                    }
                                },
                                "required": [
                                    "type"
                                ]
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "building": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "image": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                },
                                                "required": [
                                                    "id",
                                                    "type"
                                                ]
                                            }
                                        },
                                        "required": [
                                            "data"
                                        ]
                                    },
                                    "buildingDivision": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "required": [
                                    "building",
                                    "image"
                                ]
                            }
                        },
                        "required": [
                            "type",
                            "attributes",
                            "relationships"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: building_photos/{BUILDING_PHOTO_ID}GET (GET /building_photos/{BUILDING_PHOTO_ID})
  {
    name: "building_photos/{BUILDING_PHOTO_ID}GET",
    description: `Get single building photos`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUILDING_PHOTO_ID": {
                "type": "number"
            },
            "include": {
                "type": "string"
            },
        },
        "required": [
            "BUILDING_PHOTO_ID"
        ]
    }
  },
  // Tool: building_photos/{BUILDING_PHOTO_ID}PATCH (PATCH /building_photos/{BUILDING_PHOTO_ID})
  {
    name: "building_photos/{BUILDING_PHOTO_ID}PATCH",
    description: `Update building photos`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUILDING_PHOTO_ID": {
                "type": "number"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "BUILDING_PHOTO_ID"
        ]
    }
  },
  // Tool: production_stage_transitionsPOST (POST /production_stage_transitions)
  {
    name: "production_stage_transitionsPOST",
    description: `Create production stage transitions`,
    inputSchema:     {
        "type": "object",
        "properties": {}
    }
  },
  // Tool: building_scoresPOST (POST /building_scores)
  {
    name: "building_scoresPOST",
    description: `Create building scores`,
    inputSchema:     {
        "type": "object",
        "properties": {}
    }
  },
  // Tool: building_scores/{BUILDING_SCORE_ID}PATCH (PATCH /building_scores/{BUILDING_SCORE_ID})
  {
    name: "building_scores/{BUILDING_SCORE_ID}PATCH",
    description: `Update building scores`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "BUILDING_SCORE_ID": {
                "type": "string"
            },
            "requestBody": {
                "type": "string",
                "description": "Request body (content type: application/json)"
            },
        },
        "required": [
            "BUILDING_SCORE_ID"
        ]
    }
  },
  // Tool: filesGET (GET /files)
  {
    name: "filesGET",
    description: `Get files`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: files/{FILE_ID}GET (GET /files/{FILE_ID})
  {
    name: "files/{FILE_ID}GET",
    description: `Get single file`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "FILE_ID": {
                "type": "number"
            },
        },
        "required": [
            "FILE_ID"
        ]
    }
  },
  // Tool: files/{FILE_ID}PATCH (PATCH /files/{FILE_ID})
  {
    name: "files/{FILE_ID}PATCH",
    description: `Update file`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "FILE_ID": {
                "type": "number"
            },
            "requestBody": {
                "type": "object",
                "description": "The JSON request body."
            },
        },
        "required": [
            "FILE_ID"
        ]
    }
  },
  // Tool: filesPOST (POST /file/url)
  {
    name: "filesPOST",
    description: `Create files`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "file": {
                        "type": "string",
                        "description": "Base64 encoded file content."
                    },
                    "subject": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string",
                                "enum": [
                                    "properties",
                                    "companies",
                                    "productions"
                                ]
                            },
                            "id": {
                                "type": "string"
                            }
                        },
                        "required": [
                            "type",
                            "id"
                        ]
                    },
                    "tags": {
                        "type": "array"
                    },
                    "thumbnailSize": {
                        "type": "number"
                    },
                    "title": {
                        "type": "string",
                        "maxLength": 255
                    },
                    "description": {
                        "type": "string"
                    }
                },
                "required": [
                    "file",
                    "subject"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: modelFilesGET (GET /model_files)
  {
    name: "modelFilesGET",
    description: `Get model files`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "fields[profiles]": {
                "type": "string"
            },
            "fields[employees]": {
                "type": "string"
            },
            "fields[buildingDivisions]": {
                "type": "string"
            },
            "filter[tag]": {
                "type": "string",
                "description": "Values: Photos"
            },
            "filter[subjectId]": {
                "type": "number"
            },
            "filter[subjectType]": {
                "type": "number",
                "description": "Value: companies,properties,productions"
            },
            "filter[updated_at][gt]": {
                "type": "string"
            },
            "filter[updated_at][lt]": {
                "type": "string"
            },
            "include": {
                "type": "string"
            },
            "page[size]": {
                "type": "number"
            },
            "page[number]": {
                "type": "number"
            },
            "sort": {
                "type": "string"
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: actionsPOST (POST /actions)
  {
    name: "actionsPOST",
    description: `This endpoint is used for multiple purposes, and you can find various examples of its usage. Each job name comes with a different payload, depending on the specific operation being performed.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "creatorId": {
                                        "type": "number"
                                    },
                                    "job": {
                                        "type": "string",
                                        "enum": [
                                            "generate_budgets_from_production_items_by_budget_type",
                                            "generate_budgets_from_production_items",
                                            "bulk_insert_budget"
                                        ]
                                    },
                                    "status": {
                                        "type": "string"
                                    },
                                    "options": {
                                        "type": "object",
                                        "properties": {
                                            "productionId": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "productionId"
                                        ]
                                    },
                                    "shouldQueue": {
                                        "type": "boolean"
                                    },
                                    "details": {
                                        "type": "object"
                                    },
                                    "finishedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "createdAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    },
                                    "updatedAt": {
                                        "type": "string",
                                        "format": "date-time"
                                    }
                                },
                                "required": [
                                    "job",
                                    "options"
                                ]
                            },
                            "relationships": {
                                "type": "object"
                            }
                        },
                        "required": [
                            "type",
                            "attributes",
                            "relationships"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
  // Tool: notesPOST (POST /notes)
  {
    name: "notesPOST",
    description: `Creates a note attached to a production (service ticket). The \`causer\` must be an employee ID and the \`subject\` must be a production ID.`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "description": {
                                        "type": "string"
                                    },
                                    "isOfficeOnly": {
                                        "type": "boolean"
                                    },
                                    "title": {
                                        "type": "string"
                                    },
                                    "body": {
                                        "type": "string"
                                    },
                                    "isVisible": {
                                        "type": "boolean"
                                    },
                                    "isPinned": {
                                        "type": "boolean"
                                    }
                                }
                            },
                            "relationships": {
                                "type": "object",
                                "properties": {
                                    "causer": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "subject": {
                                        "type": "object",
                                        "properties": {
                                            "data": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "string"
                                                    },
                                                    "type": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "description": "The JSON request body."
            },
        },
        "required": [
            "requestBody"
        ]
    }
  },
  // Tool: transactionsPOST (POST /transactions)
  {
    name: "transactionsPOST",
    description: `Create invoice payments`,
    inputSchema:     {
        "type": "object",
        "properties": {
            "requestBody": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "object",
                                "properties": {
                                    "amount": {
                                        "type": "number",
                                        "format": "float",
                                        "minimum": 0,
                                        "maximum": 9999999999.99
                                    },
                                    "paymentMethod": {
                                        "type": "string"
                                    },
                                    "notes": {
                                        "type": "string"
                                    },
                                    "receivedDate": {
                                        "type": "string",
                                        "format": "date"
                                    },
                                    "invoiceId": {
                                        "type": "string"
                                    }
                                },
                                "required": [
                                    "amount",
                                    "paymentMethod",
                                    "invoiceId"
                                ]
                            },
                            "relationships": {
                                "type": "object"
                            }
                        },
                        "required": [
                            "type",
                            "attributes"
                        ]
                    }
                },
                "required": [
                    "data"
                ],
                "description": "The JSON request body."
            },
            "Authorization": {
                "type": "string",
                "description": "Optional API token for authentication. If not provided, will use CENTERPOINT_API_TOKEN environment variable."
            },
        }
    }
  },
];

// --- Request Handlers ---

// 1. List Available Tools Handler
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: toolsList,
  };
});

// 2. Call Tool Handler
// Corrected: Added explicit type for 'request' parameter
server.setRequestHandler(CallToolRequestSchema, async (request: CallToolRequest): Promise<CallToolResult> => {
  const { name: toolName, arguments: toolArgs } = request.params;

  const toolDefinition = toolsList.find(t => t.name === toolName);

  if (!toolDefinition) {
    console.error(`Error: Received request for unknown tool: ${toolName}`);
    return { content: [{ type: "text", text: `Error: Unknown tool requested: ${toolName}` }] };
  }

  // --- Tool Execution Logic ---

  // Handler for tool: companiesGET
  if (toolName === "companiesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/companies";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const filter_type_val = validatedArgs['filter[type]'];
      if (typeof filter_type_val !== 'undefined' && filter_type_val !== null) queryParams['filter[type]'] = filter_type_val;
      const filter_manager_val = validatedArgs['filter[manager]'];
      if (typeof filter_manager_val !== 'undefined' && filter_manager_val !== null) queryParams['filter[manager]'] = filter_manager_val;
      const filter_salesStatus_val = validatedArgs['filter[salesStatus]'];
      if (typeof filter_salesStatus_val !== 'undefined' && filter_salesStatus_val !== null) queryParams['filter[salesStatus]'] = filter_salesStatus_val;
      const filter_location_val = validatedArgs['filter[location]'];
      if (typeof filter_location_val !== 'undefined' && filter_location_val !== null) queryParams['filter[location]'] = filter_location_val;
      const filter_zipcodeRange_zipcode_val = validatedArgs['filter[zipcodeRange][zipcode]'];
      if (typeof filter_zipcodeRange_zipcode_val !== 'undefined' && filter_zipcodeRange_zipcode_val !== null) queryParams['filter[zipcodeRange][zipcode]'] = filter_zipcodeRange_zipcode_val;
      const filter_zipcodeRange_range_val = validatedArgs['filter[zipcodeRange][range]'];
      if (typeof filter_zipcodeRange_range_val !== 'undefined' && filter_zipcodeRange_range_val !== null) queryParams['filter[zipcodeRange][range]'] = filter_zipcodeRange_range_val;
      const filter_custom_customerType_val = validatedArgs['filter[custom.customerType]'];
      if (typeof filter_custom_customerType_val !== 'undefined' && filter_custom_customerType_val !== null) queryParams['filter[custom.customerType]'] = filter_custom_customerType_val;
      const filter_search_val = validatedArgs['filter[search]'];
      if (typeof filter_search_val !== 'undefined' && filter_search_val !== null) queryParams['filter[search]'] = filter_search_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: companiesPOST
  if (toolName === "companiesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/companies";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: companies/{COMPANY_ID}GET
  if (toolName === "companies/{COMPANY_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/companies/{COMPANY_ID}";
      const COMPANY_ID_val = validatedArgs['COMPANY_ID'];
      if (typeof COMPANY_ID_val !== 'undefined' && COMPANY_ID_val !== null) { urlPath = urlPath.replace("{COMPANY_ID}", encodeURIComponent(String(COMPANY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: companies/{COMPANY_ID}DELETE
  if (toolName === "companies/{COMPANY_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/companies/{COMPANY_ID}";
      const COMPANY_ID_val = validatedArgs['COMPANY_ID'];
      if (typeof COMPANY_ID_val !== 'undefined' && COMPANY_ID_val !== null) { urlPath = urlPath.replace("{COMPANY_ID}", encodeURIComponent(String(COMPANY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: companies/{COMPANY_ID}PATCH
  if (toolName === "companies/{COMPANY_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/companies/{COMPANY_ID}";
      const COMPANY_ID_val = validatedArgs['COMPANY_ID'];
      if (typeof COMPANY_ID_val !== 'undefined' && COMPANY_ID_val !== null) { urlPath = urlPath.replace("{COMPANY_ID}", encodeURIComponent(String(COMPANY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: cost_codesGET
  if (toolName === "cost_codesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/cost_codes";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: cost_codesPOST
  if (toolName === "cost_codesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/cost_codes";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: cost_codes/{COST_CODE_ID}GET
  if (toolName === "cost_codes/{COST_CODE_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/cost_codes/{COST_CODE_ID}";
      const COST_CODE_ID_val = validatedArgs['COST_CODE_ID'];
      if (typeof COST_CODE_ID_val !== 'undefined' && COST_CODE_ID_val !== null) { urlPath = urlPath.replace("{COST_CODE_ID}", encodeURIComponent(String(COST_CODE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: cost_codes/{COST_CODE_ID}DELETE
  if (toolName === "cost_codes/{COST_CODE_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/cost_codes/{COST_CODE_ID}";
      const COST_CODE_ID_val = validatedArgs['COST_CODE_ID'];
      if (typeof COST_CODE_ID_val !== 'undefined' && COST_CODE_ID_val !== null) { urlPath = urlPath.replace("{COST_CODE_ID}", encodeURIComponent(String(COST_CODE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: cost_codes/{COST_CODE_ID}PATCH
  if (toolName === "cost_codes/{COST_CODE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/cost_codes/{COST_CODE_ID}";
      const COST_CODE_ID_val = validatedArgs['COST_CODE_ID'];
      if (typeof COST_CODE_ID_val !== 'undefined' && COST_CODE_ID_val !== null) { urlPath = urlPath.replace("{COST_CODE_ID}", encodeURIComponent(String(COST_CODE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: employeesGET
  if (toolName === "employeesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/employees";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_workTimeEntries_val = validatedArgs['fields[workTimeEntries]'];
      if (typeof fields_workTimeEntries_val !== 'undefined' && fields_workTimeEntries_val !== null) queryParams['fields[workTimeEntries]'] = fields_workTimeEntries_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const filter_companyId_val = validatedArgs['filter[companyId]'];
      if (typeof filter_companyId_val !== 'undefined' && filter_companyId_val !== null) queryParams['filter[companyId]'] = filter_companyId_val;
      const filter_isActive_val = validatedArgs['filter[isActive]'];
      if (typeof filter_isActive_val !== 'undefined' && filter_isActive_val !== null) queryParams['filter[isActive]'] = filter_isActive_val;
      const filter_search_val = validatedArgs['filter[search]'];
      if (typeof filter_search_val !== 'undefined' && filter_search_val !== null) queryParams['filter[search]'] = filter_search_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: employeesPOST
  if (toolName === "employeesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/employees";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: employees/{EMPLOYEE_ID}GET
  if (toolName === "employees/{EMPLOYEE_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/employees/{EMPLOYEE_ID}";
      const EMPLOYEE_ID_val = validatedArgs['EMPLOYEE_ID'];
      if (typeof EMPLOYEE_ID_val !== 'undefined' && EMPLOYEE_ID_val !== null) { urlPath = urlPath.replace("{EMPLOYEE_ID}", encodeURIComponent(String(EMPLOYEE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: employees/{EMPLOYEE_ID}DELETE
  if (toolName === "employees/{EMPLOYEE_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/employees/{EMPLOYEE_ID}";
      const EMPLOYEE_ID_val = validatedArgs['EMPLOYEE_ID'];
      if (typeof EMPLOYEE_ID_val !== 'undefined' && EMPLOYEE_ID_val !== null) { urlPath = urlPath.replace("{EMPLOYEE_ID}", encodeURIComponent(String(EMPLOYEE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: employees/{EMPLOYEE_ID}PATCH
  if (toolName === "employees/{EMPLOYEE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/employees/{EMPLOYEE_ID}";
      const EMPLOYEE_ID_val = validatedArgs['EMPLOYEE_ID'];
      if (typeof EMPLOYEE_ID_val !== 'undefined' && EMPLOYEE_ID_val !== null) { urlPath = urlPath.replace("{EMPLOYEE_ID}", encodeURIComponent(String(EMPLOYEE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: invoicesGET
  if (toolName === "invoicesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/invoices";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const filter_lastSentAt_val = validatedArgs['filter[lastSentAt]'];
      if (typeof filter_lastSentAt_val !== 'undefined' && filter_lastSentAt_val !== null) queryParams['filter[lastSentAt]'] = filter_lastSentAt_val;
      const filter_productionDomain_val = validatedArgs['filter[productionDomain]'];
      if (typeof filter_productionDomain_val !== 'undefined' && filter_productionDomain_val !== null) queryParams['filter[productionDomain]'] = filter_productionDomain_val;
      const filter_productionWorkProfileId_val = validatedArgs['filter[productionWorkProfileId]'];
      if (typeof filter_productionWorkProfileId_val !== 'undefined' && filter_productionWorkProfileId_val !== null) queryParams['filter[productionWorkProfileId]'] = filter_productionWorkProfileId_val;
      const filter_productionTruckId_val = validatedArgs['filter[productionTruckId]'];
      if (typeof filter_productionTruckId_val !== 'undefined' && filter_productionTruckId_val !== null) queryParams['filter[productionTruckId]'] = filter_productionTruckId_val;
      const filter_invoiceType_val = validatedArgs['filter[invoiceType]'];
      if (typeof filter_invoiceType_val !== 'undefined' && filter_invoiceType_val !== null) queryParams['filter[invoiceType]'] = filter_invoiceType_val;
      const filter_productionAccountManager_val = validatedArgs['filter[productionAccountManager]'];
      if (typeof filter_productionAccountManager_val !== 'undefined' && filter_productionAccountManager_val !== null) queryParams['filter[productionAccountManager]'] = filter_productionAccountManager_val;
      const filter_productionArchived_val = validatedArgs['filter[productionArchived]'];
      if (typeof filter_productionArchived_val !== 'undefined' && filter_productionArchived_val !== null) queryParams['filter[productionArchived]'] = filter_productionArchived_val;
      const filter_hasBeenInvoiced_val = validatedArgs['filter[hasBeenInvoiced]'];
      if (typeof filter_hasBeenInvoiced_val !== 'undefined' && filter_hasBeenInvoiced_val !== null) queryParams['filter[hasBeenInvoiced]'] = filter_hasBeenInvoiced_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const aggregates_subtotal_0_val = validatedArgs['aggregates[subtotal][0]'];
      if (typeof aggregates_subtotal_0_val !== 'undefined' && aggregates_subtotal_0_val !== null) queryParams['aggregates[subtotal][0]'] = aggregates_subtotal_0_val;
      const aggregates_amount_0_val = validatedArgs['aggregates[amount][0]'];
      if (typeof aggregates_amount_0_val !== 'undefined' && aggregates_amount_0_val !== null) queryParams['aggregates[amount][0]'] = aggregates_amount_0_val;
      const aggregates_margin_0_val = validatedArgs['aggregates[margin][0]'];
      if (typeof aggregates_margin_0_val !== 'undefined' && aggregates_margin_0_val !== null) queryParams['aggregates[margin][0]'] = aggregates_margin_0_val;
      const aggregates_cost_0_val = validatedArgs['aggregates[cost][0]'];
      if (typeof aggregates_cost_0_val !== 'undefined' && aggregates_cost_0_val !== null) queryParams['aggregates[cost][0]'] = aggregates_cost_0_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: invoicesPOST
  if (toolName === "invoicesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/invoices";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: invoices/{INVOICE_ID}GET
  if (toolName === "invoices/{INVOICE_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/invoices/{INVOICE_ID}";
      const INVOICE_ID_val = validatedArgs['INVOICE_ID'];
      if (typeof INVOICE_ID_val !== 'undefined' && INVOICE_ID_val !== null) { urlPath = urlPath.replace("{INVOICE_ID}", encodeURIComponent(String(INVOICE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_transactions_val = validatedArgs['fields[transactions]'];
      if (typeof fields_transactions_val !== 'undefined' && fields_transactions_val !== null) queryParams['fields[transactions]'] = fields_transactions_val;
      const fields_productionDays_val = validatedArgs['fields[productionDays]'];
      if (typeof fields_productionDays_val !== 'undefined' && fields_productionDays_val !== null) queryParams['fields[productionDays]'] = fields_productionDays_val;
      const fields_products_val = validatedArgs['fields[products]'];
      if (typeof fields_products_val !== 'undefined' && fields_products_val !== null) queryParams['fields[products]'] = fields_products_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: invoices/{INVOICE_ID}PATCH
  if (toolName === "invoices/{INVOICE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/invoices/{INVOICE_ID}";
      const INVOICE_ID_val = validatedArgs['INVOICE_ID'];
      if (typeof INVOICE_ID_val !== 'undefined' && INVOICE_ID_val !== null) { urlPath = urlPath.replace("{INVOICE_ID}", encodeURIComponent(String(INVOICE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_transactions_val = validatedArgs['fields[transactions]'];
      if (typeof fields_transactions_val !== 'undefined' && fields_transactions_val !== null) queryParams['fields[transactions]'] = fields_transactions_val;
      const fields_productionDays_val = validatedArgs['fields[productionDays]'];
      if (typeof fields_productionDays_val !== 'undefined' && fields_productionDays_val !== null) queryParams['fields[productionDays]'] = fields_productionDays_val;
      const fields_products_val = validatedArgs['fields[products]'];
      if (typeof fields_products_val !== 'undefined' && fields_products_val !== null) queryParams['fields[products]'] = fields_products_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: materialsGET
  if (toolName === "materialsGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/materials";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_materials_val = validatedArgs['fields[materials]'];
      if (typeof fields_materials_val !== 'undefined' && fields_materials_val !== null) queryParams['fields[materials]'] = fields_materials_val;
      const filter_isChild_val = validatedArgs['filter[isChild]'];
      if (typeof filter_isChild_val !== 'undefined' && filter_isChild_val !== null) queryParams['filter[isChild]'] = filter_isChild_val;
      const filter_manufacturer_val = validatedArgs['filter[manufacturer]'];
      if (typeof filter_manufacturer_val !== 'undefined' && filter_manufacturer_val !== null) queryParams['filter[manufacturer]'] = filter_manufacturer_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: materialsPOST
  if (toolName === "materialsPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/materials";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: materials/{MATERIAL_ID}GET
  if (toolName === "materials/{MATERIAL_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/materials/{MATERIAL_ID}";
      const MATERIAL_ID_val = validatedArgs['MATERIAL_ID'];
      if (typeof MATERIAL_ID_val !== 'undefined' && MATERIAL_ID_val !== null) { urlPath = urlPath.replace("{MATERIAL_ID}", encodeURIComponent(String(MATERIAL_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: materials/{MATERIAL_ID}DELETE
  if (toolName === "materials/{MATERIAL_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/materials/{MATERIAL_ID}";
      const MATERIAL_ID_val = validatedArgs['MATERIAL_ID'];
      if (typeof MATERIAL_ID_val !== 'undefined' && MATERIAL_ID_val !== null) { urlPath = urlPath.replace("{MATERIAL_ID}", encodeURIComponent(String(MATERIAL_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: materials/{MATERIAL_ID}PATCH
  if (toolName === "materials/{MATERIAL_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/materials/{MATERIAL_ID}";
      const MATERIAL_ID_val = validatedArgs['MATERIAL_ID'];
      if (typeof MATERIAL_ID_val !== 'undefined' && MATERIAL_ID_val !== null) { urlPath = urlPath.replace("{MATERIAL_ID}", encodeURIComponent(String(MATERIAL_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: opportunitiesGET
  if (toolName === "opportunitiesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/opportunities";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_leadTypes_val = validatedArgs['fields[leadTypes]'];
      if (typeof fields_leadTypes_val !== 'undefined' && fields_leadTypes_val !== null) queryParams['fields[leadTypes]'] = fields_leadTypes_val;
      const fields_workflowStages_val = validatedArgs['fields[workflowStages]'];
      if (typeof fields_workflowStages_val !== 'undefined' && fields_workflowStages_val !== null) queryParams['fields[workflowStages]'] = fields_workflowStages_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const filter_latestStageTransitionedAt_val = validatedArgs['filter[latestStageTransitionedAt]'];
      if (typeof filter_latestStageTransitionedAt_val !== 'undefined' && filter_latestStageTransitionedAt_val !== null) queryParams['filter[latestStageTransitionedAt]'] = filter_latestStageTransitionedAt_val;
      const filter_salesProfile_val = validatedArgs['filter[salesProfile]'];
      if (typeof filter_salesProfile_val !== 'undefined' && filter_salesProfile_val !== null) queryParams['filter[salesProfile]'] = filter_salesProfile_val;
      const filter_opportunityType_val = validatedArgs['filter[opportunityType]'];
      if (typeof filter_opportunityType_val !== 'undefined' && filter_opportunityType_val !== null) queryParams['filter[opportunityType]'] = filter_opportunityType_val;
      const filter_isArchived_val = validatedArgs['filter[isArchived]'];
      if (typeof filter_isArchived_val !== 'undefined' && filter_isArchived_val !== null) queryParams['filter[isArchived]'] = filter_isArchived_val;
      const filter_forecastedAt_val = validatedArgs['filter[forecastedAt]'];
      if (typeof filter_forecastedAt_val !== 'undefined' && filter_forecastedAt_val !== null) queryParams['filter[forecastedAt]'] = filter_forecastedAt_val;
      const filter_status_val = validatedArgs['filter[status]'];
      if (typeof filter_status_val !== 'undefined' && filter_status_val !== null) queryParams['filter[status]'] = filter_status_val;
      const filter_workflowStageId_val = validatedArgs['filter[workflowStageId]'];
      if (typeof filter_workflowStageId_val !== 'undefined' && filter_workflowStageId_val !== null) queryParams['filter[workflowStageId]'] = filter_workflowStageId_val;
      const filter_leadType_val = validatedArgs['filter[leadType]'];
      if (typeof filter_leadType_val !== 'undefined' && filter_leadType_val !== null) queryParams['filter[leadType]'] = filter_leadType_val;
      const filter_custom_division_val = validatedArgs['filter[custom.division]'];
      if (typeof filter_custom_division_val !== 'undefined' && filter_custom_division_val !== null) queryParams['filter[custom.division]'] = filter_custom_division_val;
      const filter_search_val = validatedArgs['filter[search]'];
      if (typeof filter_search_val !== 'undefined' && filter_search_val !== null) queryParams['filter[search]'] = filter_search_val;
      const filter_isOpportunity_val = validatedArgs['filter[isOpportunity]'];
      if (typeof filter_isOpportunity_val !== 'undefined' && filter_isOpportunity_val !== null) queryParams['filter[isOpportunity]'] = filter_isOpportunity_val;
      const reports_0_val = validatedArgs['reports[0]'];
      if (typeof reports_0_val !== 'undefined' && reports_0_val !== null) queryParams['reports[0]'] = reports_0_val;
      const reports_1_val = validatedArgs['reports[1]'];
      if (typeof reports_1_val !== 'undefined' && reports_1_val !== null) queryParams['reports[1]'] = reports_1_val;
      const reports_2_val = validatedArgs['reports[2]'];
      if (typeof reports_2_val !== 'undefined' && reports_2_val !== null) queryParams['reports[2]'] = reports_2_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: opportunitiesPOST
  if (toolName === "opportunitiesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/opportunities";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_documents_val = validatedArgs['fields[documents]'];
      if (typeof fields_documents_val !== 'undefined' && fields_documents_val !== null) queryParams['fields[documents]'] = fields_documents_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_primaryProposal_val = validatedArgs['fields[primaryProposal]'];
      if (typeof fields_primaryProposal_val !== 'undefined' && fields_primaryProposal_val !== null) queryParams['fields[primaryProposal]'] = fields_primaryProposal_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: opportunities/{OPPORTUNITY_ID}GET
  if (toolName === "opportunities/{OPPORTUNITY_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/opportunities/{OPPORTUNITY_ID}";
      const OPPORTUNITY_ID_val = validatedArgs['OPPORTUNITY_ID'];
      if (typeof OPPORTUNITY_ID_val !== 'undefined' && OPPORTUNITY_ID_val !== null) { urlPath = urlPath.replace("{OPPORTUNITY_ID}", encodeURIComponent(String(OPPORTUNITY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_documents_val = validatedArgs['fields[documents]'];
      if (typeof fields_documents_val !== 'undefined' && fields_documents_val !== null) queryParams['fields[documents]'] = fields_documents_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_primaryProposal_val = validatedArgs['fields[primaryProposal]'];
      if (typeof fields_primaryProposal_val !== 'undefined' && fields_primaryProposal_val !== null) queryParams['fields[primaryProposal]'] = fields_primaryProposal_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: opportunities/{OPPORTUNITY_ID}DELETE
  if (toolName === "opportunities/{OPPORTUNITY_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/opportunities/{OPPORTUNITY_ID}";
      const OPPORTUNITY_ID_val = validatedArgs['OPPORTUNITY_ID'];
      if (typeof OPPORTUNITY_ID_val !== 'undefined' && OPPORTUNITY_ID_val !== null) { urlPath = urlPath.replace("{OPPORTUNITY_ID}", encodeURIComponent(String(OPPORTUNITY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: opportunities/{OPPORTUNITY_ID}PATCH
  if (toolName === "opportunities/{OPPORTUNITY_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/opportunities/{OPPORTUNITY_ID}";
      const OPPORTUNITY_ID_val = validatedArgs['OPPORTUNITY_ID'];
      if (typeof OPPORTUNITY_ID_val !== 'undefined' && OPPORTUNITY_ID_val !== null) { urlPath = urlPath.replace("{OPPORTUNITY_ID}", encodeURIComponent(String(OPPORTUNITY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_documents_val = validatedArgs['fields[documents]'];
      if (typeof fields_documents_val !== 'undefined' && fields_documents_val !== null) queryParams['fields[documents]'] = fields_documents_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_primaryProposal_val = validatedArgs['fields[primaryProposal]'];
      if (typeof fields_primaryProposal_val !== 'undefined' && fields_primaryProposal_val !== null) queryParams['fields[primaryProposal]'] = fields_primaryProposal_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: product_templatesGET
  if (toolName === "product_templatesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/product_templates";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const filter_domain_val = validatedArgs['filter[domain]'];
      if (typeof filter_domain_val !== 'undefined' && filter_domain_val !== null) queryParams['filter[domain]'] = filter_domain_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: product_templatesPOST
  if (toolName === "product_templatesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/product_templates";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: product_templates/{PRODUCT_TEMPLATE_ID}GET
  if (toolName === "product_templates/{PRODUCT_TEMPLATE_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/product_templates/{PRODUCT_TEMPLATE_ID}";
      const PRODUCT_TEMPLATE_ID_val = validatedArgs['PRODUCT_TEMPLATE_ID'];
      if (typeof PRODUCT_TEMPLATE_ID_val !== 'undefined' && PRODUCT_TEMPLATE_ID_val !== null) { urlPath = urlPath.replace("{PRODUCT_TEMPLATE_ID}", encodeURIComponent(String(PRODUCT_TEMPLATE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: product_templates/{PRODUCT_TEMPLATE_ID}DELETE
  if (toolName === "product_templates/{PRODUCT_TEMPLATE_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/product_templates/{PRODUCT_TEMPLATE_ID}";
      const PRODUCT_TEMPLATE_ID_val = validatedArgs['PRODUCT_TEMPLATE_ID'];
      if (typeof PRODUCT_TEMPLATE_ID_val !== 'undefined' && PRODUCT_TEMPLATE_ID_val !== null) { urlPath = urlPath.replace("{PRODUCT_TEMPLATE_ID}", encodeURIComponent(String(PRODUCT_TEMPLATE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: product_templates/{PRODUCT_TEMPLATE_ID}PATCH
  if (toolName === "product_templates/{PRODUCT_TEMPLATE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/product_templates/{PRODUCT_TEMPLATE_ID}";
      const PRODUCT_TEMPLATE_ID_val = validatedArgs['PRODUCT_TEMPLATE_ID'];
      if (typeof PRODUCT_TEMPLATE_ID_val !== 'undefined' && PRODUCT_TEMPLATE_ID_val !== null) { urlPath = urlPath.replace("{PRODUCT_TEMPLATE_ID}", encodeURIComponent(String(PRODUCT_TEMPLATE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_materialsGET
  if (toolName === "production_materialsGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_materials";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productionMaterials_val = validatedArgs['fields[productionMaterials]'];
      if (typeof fields_productionMaterials_val !== 'undefined' && fields_productionMaterials_val !== null) queryParams['fields[productionMaterials]'] = fields_productionMaterials_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_materials_val = validatedArgs['fields[materials]'];
      if (typeof fields_materials_val !== 'undefined' && fields_materials_val !== null) queryParams['fields[materials]'] = fields_materials_val;
      const filter_createdAt_gt_val = validatedArgs['filter[createdAt][gt]'];
      if (typeof filter_createdAt_gt_val !== 'undefined' && filter_createdAt_gt_val !== null) queryParams['filter[createdAt][gt]'] = filter_createdAt_gt_val;
      const filter_createdAt_lt_val = validatedArgs['filter[createdAt][lt]'];
      if (typeof filter_createdAt_lt_val !== 'undefined' && filter_createdAt_lt_val !== null) queryParams['filter[createdAt][lt]'] = filter_createdAt_lt_val;
      const filter_createdAt_timezone_val = validatedArgs['filter[createdAt][timezone]'];
      if (typeof filter_createdAt_timezone_val !== 'undefined' && filter_createdAt_timezone_val !== null) queryParams['filter[createdAt][timezone]'] = filter_createdAt_timezone_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_materialsPOST
  if (toolName === "production_materialsPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_materials";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productionMaterials_val = validatedArgs['fields[productionMaterials]'];
      if (typeof fields_productionMaterials_val !== 'undefined' && fields_productionMaterials_val !== null) queryParams['fields[productionMaterials]'] = fields_productionMaterials_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_materials/{PRODUCTION_MATERIAL_ID}DELETE
  if (toolName === "production_materials/{PRODUCTION_MATERIAL_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_materials/{PRODUCTION_MATERIAL_ID}";
      const PRODUCTION_MATERIAL_ID_val = validatedArgs['PRODUCTION_MATERIAL_ID'];
      if (typeof PRODUCTION_MATERIAL_ID_val !== 'undefined' && PRODUCTION_MATERIAL_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_MATERIAL_ID}", encodeURIComponent(String(PRODUCTION_MATERIAL_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_materials/{PRODUCTION_MATERIAL_ID}PATCH
  if (toolName === "production_materials/{PRODUCTION_MATERIAL_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_materials/{PRODUCTION_MATERIAL_ID}";
      const PRODUCTION_MATERIAL_ID_val = validatedArgs['PRODUCTION_MATERIAL_ID'];
      if (typeof PRODUCTION_MATERIAL_ID_val !== 'undefined' && PRODUCTION_MATERIAL_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_MATERIAL_ID}", encodeURIComponent(String(PRODUCTION_MATERIAL_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productionMaterials_val = validatedArgs['fields[productionMaterials]'];
      if (typeof fields_productionMaterials_val !== 'undefined' && fields_productionMaterials_val !== null) queryParams['fields[productionMaterials]'] = fields_productionMaterials_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: productionsGET
  if (toolName === "productionsGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/productions";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_locations_val = validatedArgs['fields[locations]'];
      if (typeof fields_locations_val !== 'undefined' && fields_locations_val !== null) queryParams['fields[locations]'] = fields_locations_val;
      const fields_subcontractorProfiles_val = validatedArgs['fields[subcontractorProfiles]'];
      if (typeof fields_subcontractorProfiles_val !== 'undefined' && fields_subcontractorProfiles_val !== null) queryParams['fields[subcontractorProfiles]'] = fields_subcontractorProfiles_val;
      const fields_workflowStages_val = validatedArgs['fields[workflowStages]'];
      if (typeof fields_workflowStages_val !== 'undefined' && fields_workflowStages_val !== null) queryParams['fields[workflowStages]'] = fields_workflowStages_val;
      const filter_latestStageTransitionedAt_val = validatedArgs['filter[latestStageTransitionedAt]'];
      if (typeof filter_latestStageTransitionedAt_val !== 'undefined' && filter_latestStageTransitionedAt_val !== null) queryParams['filter[latestStageTransitionedAt]'] = filter_latestStageTransitionedAt_val;
      const filter_location_val = validatedArgs['filter[location]'];
      if (typeof filter_location_val !== 'undefined' && filter_location_val !== null) queryParams['filter[location]'] = filter_location_val;
      const filter_isArchived_val = validatedArgs['filter[isArchived]'];
      if (typeof filter_isArchived_val !== 'undefined' && filter_isArchived_val !== null) queryParams['filter[isArchived]'] = filter_isArchived_val;
      const filter_domain_val = validatedArgs['filter[domain]'];
      if (typeof filter_domain_val !== 'undefined' && filter_domain_val !== null) queryParams['filter[domain]'] = filter_domain_val;
      const filter_worker_val = validatedArgs['filter[worker]'];
      if (typeof filter_worker_val !== 'undefined' && filter_worker_val !== null) queryParams['filter[worker]'] = filter_worker_val;
      const filter_status_val = validatedArgs['filter[status]'];
      if (typeof filter_status_val !== 'undefined' && filter_status_val !== null) queryParams['filter[status]'] = filter_status_val;
      const filter_workflowStageId_val = validatedArgs['filter[workflowStageId]'];
      if (typeof filter_workflowStageId_val !== 'undefined' && filter_workflowStageId_val !== null) queryParams['filter[workflowStageId]'] = filter_workflowStageId_val;
      const filter_search_val = validatedArgs['filter[search]'];
      if (typeof filter_search_val !== 'undefined' && filter_search_val !== null) queryParams['filter[search]'] = filter_search_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: productions/{PRODUCTION_ID}GET
  if (toolName === "productions/{PRODUCTION_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/productions/{PRODUCTION_ID}";
      const PRODUCTION_ID_val = validatedArgs['PRODUCTION_ID'];
      if (typeof PRODUCTION_ID_val !== 'undefined' && PRODUCTION_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_ID}", encodeURIComponent(String(PRODUCTION_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_productionDays_val = validatedArgs['fields[productionDays]'];
      if (typeof fields_productionDays_val !== 'undefined' && fields_productionDays_val !== null) queryParams['fields[productionDays]'] = fields_productionDays_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: productions/{PRODUCTION_ID}DELETE
  if (toolName === "productions/{PRODUCTION_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/productions/{PRODUCTION_ID}";
      const PRODUCTION_ID_val = validatedArgs['PRODUCTION_ID'];
      if (typeof PRODUCTION_ID_val !== 'undefined' && PRODUCTION_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_ID}", encodeURIComponent(String(PRODUCTION_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: productions/{PRODUCTION_ID}PATCH
  if (toolName === "productions/{PRODUCTION_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/productions/{PRODUCTION_ID}";
      const PRODUCTION_ID_val = validatedArgs['PRODUCTION_ID'];
      if (typeof PRODUCTION_ID_val !== 'undefined' && PRODUCTION_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_ID}", encodeURIComponent(String(PRODUCTION_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_productionDays_val = validatedArgs['fields[productionDays]'];
      if (typeof fields_productionDays_val !== 'undefined' && fields_productionDays_val !== null) queryParams['fields[productionDays]'] = fields_productionDays_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: productions/{PRODUCTION_ID}/production_materialsGET
  if (toolName === "productions/{PRODUCTION_ID}/production_materialsGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/productions/{PRODUCTION_ID}/production_materials";
      const PRODUCTION_ID_val = validatedArgs['PRODUCTION_ID'];
      if (typeof PRODUCTION_ID_val !== 'undefined' && PRODUCTION_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_ID}", encodeURIComponent(String(PRODUCTION_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: productions/{PRODUCTION_ID}/purchase_ordersGET
  if (toolName === "productions/{PRODUCTION_ID}/purchase_ordersGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/productions/{PRODUCTION_ID}/purchase_orders";
      const PRODUCTION_ID_val = validatedArgs['PRODUCTION_ID'];
      if (typeof PRODUCTION_ID_val !== 'undefined' && PRODUCTION_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_ID}", encodeURIComponent(String(PRODUCTION_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: profilesGET
  if (toolName === "profilesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/profiles";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const filter_company_type_val = validatedArgs['filter[company.type]'];
      if (typeof filter_company_type_val !== 'undefined' && filter_company_type_val !== null) queryParams['filter[company.type]'] = filter_company_type_val;
      const filter_company_saleStatus_val = validatedArgs['filter[company.saleStatus]'];
      if (typeof filter_company_saleStatus_val !== 'undefined' && filter_company_saleStatus_val !== null) queryParams['filter[company.saleStatus]'] = filter_company_saleStatus_val;
      const filter_company_managerId_val = validatedArgs['filter[company.managerId]'];
      if (typeof filter_company_managerId_val !== 'undefined' && filter_company_managerId_val !== null) queryParams['filter[company.managerId]'] = filter_company_managerId_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: profilesPOST
  if (toolName === "profilesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/profiles";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: profiles/{PROFILE_ID}GET
  if (toolName === "profiles/{PROFILE_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/profiles/{PROFILE_ID}";
      const PROFILE_ID_val = validatedArgs['PROFILE_ID'];
      if (typeof PROFILE_ID_val !== 'undefined' && PROFILE_ID_val !== null) { urlPath = urlPath.replace("{PROFILE_ID}", encodeURIComponent(String(PROFILE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: profiles/{PROFILE_ID}DELETE
  if (toolName === "profiles/{PROFILE_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/profiles/{PROFILE_ID}";
      const PROFILE_ID_val = validatedArgs['PROFILE_ID'];
      if (typeof PROFILE_ID_val !== 'undefined' && PROFILE_ID_val !== null) { urlPath = urlPath.replace("{PROFILE_ID}", encodeURIComponent(String(PROFILE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: profiles/{PROFILE_ID}PATCH
  if (toolName === "profiles/{PROFILE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/profiles/{PROFILE_ID}";
      const PROFILE_ID_val = validatedArgs['PROFILE_ID'];
      if (typeof PROFILE_ID_val !== 'undefined' && PROFILE_ID_val !== null) { urlPath = urlPath.replace("{PROFILE_ID}", encodeURIComponent(String(PROFILE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: propertiesGET
  if (toolName === "propertiesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/properties";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_locations_val = validatedArgs['fields[locations]'];
      if (typeof fields_locations_val !== 'undefined' && fields_locations_val !== null) queryParams['fields[locations]'] = fields_locations_val;
      const filter_type_val = validatedArgs['filter[type]'];
      if (typeof filter_type_val !== 'undefined' && filter_type_val !== null) queryParams['filter[type]'] = filter_type_val;
      const filter_location_val = validatedArgs['filter[location]'];
      if (typeof filter_location_val !== 'undefined' && filter_location_val !== null) queryParams['filter[location]'] = filter_location_val;
      const filter_roofSize_val = validatedArgs['filter[roofSize]'];
      if (typeof filter_roofSize_val !== 'undefined' && filter_roofSize_val !== null) queryParams['filter[roofSize]'] = filter_roofSize_val;
      const filter_search_val = validatedArgs['filter[search]'];
      if (typeof filter_search_val !== 'undefined' && filter_search_val !== null) queryParams['filter[search]'] = filter_search_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: propertiesPOST
  if (toolName === "propertiesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/properties";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: properties/{PROPERTY_ID}GET
  if (toolName === "properties/{PROPERTY_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/properties/{PROPERTY_ID}";
      const PROPERTY_ID_val = validatedArgs['PROPERTY_ID'];
      if (typeof PROPERTY_ID_val !== 'undefined' && PROPERTY_ID_val !== null) { urlPath = urlPath.replace("{PROPERTY_ID}", encodeURIComponent(String(PROPERTY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: properties/{PROPERTY_ID}DELETE
  if (toolName === "properties/{PROPERTY_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/properties/{PROPERTY_ID}";
      const PROPERTY_ID_val = validatedArgs['PROPERTY_ID'];
      if (typeof PROPERTY_ID_val !== 'undefined' && PROPERTY_ID_val !== null) { urlPath = urlPath.replace("{PROPERTY_ID}", encodeURIComponent(String(PROPERTY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: properties/{PROPERTY_ID}PATCH
  if (toolName === "properties/{PROPERTY_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/properties/{PROPERTY_ID}";
      const PROPERTY_ID_val = validatedArgs['PROPERTY_ID'];
      if (typeof PROPERTY_ID_val !== 'undefined' && PROPERTY_ID_val !== null) { urlPath = urlPath.replace("{PROPERTY_ID}", encodeURIComponent(String(PROPERTY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: purchase_ordersGET
  if (toolName === "purchase_ordersGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/purchase_orders";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const filter_productionDomain_val = validatedArgs['filter[productionDomain]'];
      if (typeof filter_productionDomain_val !== 'undefined' && filter_productionDomain_val !== null) queryParams['filter[productionDomain]'] = filter_productionDomain_val;
      const filter_workDate_gt_val = validatedArgs['filter[workDate][gt]'];
      if (typeof filter_workDate_gt_val !== 'undefined' && filter_workDate_gt_val !== null) queryParams['filter[workDate][gt]'] = filter_workDate_gt_val;
      const filter_workDate_lt_val = validatedArgs['filter[workDate][lt]'];
      if (typeof filter_workDate_lt_val !== 'undefined' && filter_workDate_lt_val !== null) queryParams['filter[workDate][lt]'] = filter_workDate_lt_val;
      const filter_workDate_timezone_val = validatedArgs['filter[workDate][timezone]'];
      if (typeof filter_workDate_timezone_val !== 'undefined' && filter_workDate_timezone_val !== null) queryParams['filter[workDate][timezone]'] = filter_workDate_timezone_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: purchase_ordersPOST
  if (toolName === "purchase_ordersPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/purchase_orders";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: purchase_orders/{PURCHASE_ORDER_ID}DELETE
  if (toolName === "purchase_orders/{PURCHASE_ORDER_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/purchase_orders/{PURCHASE_ORDER_ID}";
      const PURCHASE_ORDER_ID_val = validatedArgs['PURCHASE_ORDER_ID'];
      if (typeof PURCHASE_ORDER_ID_val !== 'undefined' && PURCHASE_ORDER_ID_val !== null) { urlPath = urlPath.replace("{PURCHASE_ORDER_ID}", encodeURIComponent(String(PURCHASE_ORDER_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: purchase_orders/{PURCHASE_ORDER_ID}PATCH
  if (toolName === "purchase_orders/{PURCHASE_ORDER_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/purchase_orders/{PURCHASE_ORDER_ID}";
      const PURCHASE_ORDER_ID_val = validatedArgs['PURCHASE_ORDER_ID'];
      if (typeof PURCHASE_ORDER_ID_val !== 'undefined' && PURCHASE_ORDER_ID_val !== null) { urlPath = urlPath.replace("{PURCHASE_ORDER_ID}", encodeURIComponent(String(PURCHASE_ORDER_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: servicesGET
  if (toolName === "servicesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/services";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_locations_val = validatedArgs['fields[locations]'];
      if (typeof fields_locations_val !== 'undefined' && fields_locations_val !== null) queryParams['fields[locations]'] = fields_locations_val;
      const fields_subcontractorProfiles_val = validatedArgs['fields[subcontractorProfiles]'];
      if (typeof fields_subcontractorProfiles_val !== 'undefined' && fields_subcontractorProfiles_val !== null) queryParams['fields[subcontractorProfiles]'] = fields_subcontractorProfiles_val;
      const fields_workflowStages_val = validatedArgs['fields[workflowStages]'];
      if (typeof fields_workflowStages_val !== 'undefined' && fields_workflowStages_val !== null) queryParams['fields[workflowStages]'] = fields_workflowStages_val;
      const filter_latestStageTransitionedAt_val = validatedArgs['filter[latestStageTransitionedAt]'];
      if (typeof filter_latestStageTransitionedAt_val !== 'undefined' && filter_latestStageTransitionedAt_val !== null) queryParams['filter[latestStageTransitionedAt]'] = filter_latestStageTransitionedAt_val;
      const filter_isArchived_val = validatedArgs['filter[isArchived]'];
      if (typeof filter_isArchived_val !== 'undefined' && filter_isArchived_val !== null) queryParams['filter[isArchived]'] = filter_isArchived_val;
      const filter_domain_val = validatedArgs['filter[domain]'];
      if (typeof filter_domain_val !== 'undefined' && filter_domain_val !== null) queryParams['filter[domain]'] = filter_domain_val;
      const filter_isHeld_val = validatedArgs['filter[isHeld]'];
      if (typeof filter_isHeld_val !== 'undefined' && filter_isHeld_val !== null) queryParams['filter[isHeld]'] = filter_isHeld_val;
      const filter_workflowStageId_val = validatedArgs['filter[workflowStageId]'];
      if (typeof filter_workflowStageId_val !== 'undefined' && filter_workflowStageId_val !== null) queryParams['filter[workflowStageId]'] = filter_workflowStageId_val;
      const filter_workType_val = validatedArgs['filter[workType]'];
      if (typeof filter_workType_val !== 'undefined' && filter_workType_val !== null) queryParams['filter[workType]'] = filter_workType_val;
      const filter_managerId_val = validatedArgs['filter[managerId]'];
      if (typeof filter_managerId_val !== 'undefined' && filter_managerId_val !== null) queryParams['filter[managerId]'] = filter_managerId_val;
      const filter_worker_val = validatedArgs['filter[worker]'];
      if (typeof filter_worker_val !== 'undefined' && filter_worker_val !== null) queryParams['filter[worker]'] = filter_worker_val;
      const filter_location_val = validatedArgs['filter[location]'];
      if (typeof filter_location_val !== 'undefined' && filter_location_val !== null) queryParams['filter[location]'] = filter_location_val;
      const filter_custom_division_val = validatedArgs['filter[custom.division]'];
      if (typeof filter_custom_division_val !== 'undefined' && filter_custom_division_val !== null) queryParams['filter[custom.division]'] = filter_custom_division_val;
      const filter_search_val = validatedArgs['filter[search]'];
      if (typeof filter_search_val !== 'undefined' && filter_search_val !== null) queryParams['filter[search]'] = filter_search_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: servicesPOST
  if (toolName === "servicesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/services";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_invoices_val = validatedArgs['fields[invoices]'];
      if (typeof fields_invoices_val !== 'undefined' && fields_invoices_val !== null) queryParams['fields[invoices]'] = fields_invoices_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const fields_relatedProductions_val = validatedArgs['fields[relatedProductions]'];
      if (typeof fields_relatedProductions_val !== 'undefined' && fields_relatedProductions_val !== null) queryParams['fields[relatedProductions]'] = fields_relatedProductions_val;
      const fields_productTemplateTags_val = validatedArgs['fields[productTemplateTags]'];
      if (typeof fields_productTemplateTags_val !== 'undefined' && fields_productTemplateTags_val !== null) queryParams['fields[productTemplateTags]'] = fields_productTemplateTags_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: services/{SERVICE_ID}GET
  if (toolName === "services/{SERVICE_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/services/{SERVICE_ID}";
      const SERVICE_ID_val = validatedArgs['SERVICE_ID'];
      if (typeof SERVICE_ID_val !== 'undefined' && SERVICE_ID_val !== null) { urlPath = urlPath.replace("{SERVICE_ID}", encodeURIComponent(String(SERVICE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_documents_val = validatedArgs['fields[documents]'];
      if (typeof fields_documents_val !== 'undefined' && fields_documents_val !== null) queryParams['fields[documents]'] = fields_documents_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_primaryProposal_val = validatedArgs['fields[primaryProposal]'];
      if (typeof fields_primaryProposal_val !== 'undefined' && fields_primaryProposal_val !== null) queryParams['fields[primaryProposal]'] = fields_primaryProposal_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: services/{SERVICE_ID}DELETE
  if (toolName === "services/{SERVICE_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/services/{SERVICE_ID}";
      const SERVICE_ID_val = validatedArgs['SERVICE_ID'];
      if (typeof SERVICE_ID_val !== 'undefined' && SERVICE_ID_val !== null) { urlPath = urlPath.replace("{SERVICE_ID}", encodeURIComponent(String(SERVICE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: services/{SERVICE_ID}PATCH
  if (toolName === "services/{SERVICE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/services/{SERVICE_ID}";
      const SERVICE_ID_val = validatedArgs['SERVICE_ID'];
      if (typeof SERVICE_ID_val !== 'undefined' && SERVICE_ID_val !== null) { urlPath = urlPath.replace("{SERVICE_ID}", encodeURIComponent(String(SERVICE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_invoices_val = validatedArgs['fields[invoices]'];
      if (typeof fields_invoices_val !== 'undefined' && fields_invoices_val !== null) queryParams['fields[invoices]'] = fields_invoices_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const fields_relatedProductions_val = validatedArgs['fields[relatedProductions]'];
      if (typeof fields_relatedProductions_val !== 'undefined' && fields_relatedProductions_val !== null) queryParams['fields[relatedProductions]'] = fields_relatedProductions_val;
      const fields_productTemplateTags_val = validatedArgs['fields[productTemplateTags]'];
      if (typeof fields_productTemplateTags_val !== 'undefined' && fields_productTemplateTags_val !== null) queryParams['fields[productTemplateTags]'] = fields_productTemplateTags_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: tax_codesGET
  if (toolName === "tax_codesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tax_codes";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: tax_codesPOST
  if (toolName === "tax_codesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tax_codes";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: tax_codes/{TAX_CODE_ID}GET
  if (toolName === "tax_codes/{TAX_CODE_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tax_codes/{TAX_CODE_ID}";
      const TAX_CODE_ID_val = validatedArgs['TAX_CODE_ID'];
      if (typeof TAX_CODE_ID_val !== 'undefined' && TAX_CODE_ID_val !== null) { urlPath = urlPath.replace("{TAX_CODE_ID}", encodeURIComponent(String(TAX_CODE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: tax_codes/{TAX_CODE_ID}DELETE
  if (toolName === "tax_codes/{TAX_CODE_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tax_codes/{TAX_CODE_ID}";
      const TAX_CODE_ID_val = validatedArgs['TAX_CODE_ID'];
      if (typeof TAX_CODE_ID_val !== 'undefined' && TAX_CODE_ID_val !== null) { urlPath = urlPath.replace("{TAX_CODE_ID}", encodeURIComponent(String(TAX_CODE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: tax_codes/{TAX_CODE_ID}PATCH
  if (toolName === "tax_codes/{TAX_CODE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tax_codes/{TAX_CODE_ID}";
      const TAX_CODE_ID_val = validatedArgs['TAX_CODE_ID'];
      if (typeof TAX_CODE_ID_val !== 'undefined' && TAX_CODE_ID_val !== null) { urlPath = urlPath.replace("{TAX_CODE_ID}", encodeURIComponent(String(TAX_CODE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: work_time_entriesGET
  if (toolName === "work_time_entriesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/work_time_entries";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_workTimeEntries_val = validatedArgs['fields[workTimeEntries]'];
      if (typeof fields_workTimeEntries_val !== 'undefined' && fields_workTimeEntries_val !== null) queryParams['fields[workTimeEntries]'] = fields_workTimeEntries_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const filter_inAt_gt_val = validatedArgs['filter[inAt][gt]'];
      if (typeof filter_inAt_gt_val !== 'undefined' && filter_inAt_gt_val !== null) queryParams['filter[inAt][gt]'] = filter_inAt_gt_val;
      const filter_inAt_lt_val = validatedArgs['filter[inAt][lt]'];
      if (typeof filter_inAt_lt_val !== 'undefined' && filter_inAt_lt_val !== null) queryParams['filter[inAt][lt]'] = filter_inAt_lt_val;
      const filter_inAt_timezone_val = validatedArgs['filter[inAt][timezone]'];
      if (typeof filter_inAt_timezone_val !== 'undefined' && filter_inAt_timezone_val !== null) queryParams['filter[inAt][timezone]'] = filter_inAt_timezone_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const filter_isTimekeeping_val = validatedArgs['filter[isTimekeeping]'];
      if (typeof filter_isTimekeeping_val !== 'undefined' && filter_isTimekeeping_val !== null) queryParams['filter[isTimekeeping]'] = filter_isTimekeeping_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: work_time_entriesPOST
  if (toolName === "work_time_entriesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/work_time_entries";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: work_time_entries/{WORK_TIME_ENTRIES_ID}GET
  if (toolName === "work_time_entries/{WORK_TIME_ENTRIES_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/work_time_entries/{WORK_TIME_ENTRIES_ID}";
      const WORK_TIME_ENTRIES_ID_val = validatedArgs['WORK_TIME_ENTRIES_ID'];
      if (typeof WORK_TIME_ENTRIES_ID_val !== 'undefined' && WORK_TIME_ENTRIES_ID_val !== null) { urlPath = urlPath.replace("{WORK_TIME_ENTRIES_ID}", encodeURIComponent(String(WORK_TIME_ENTRIES_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: work_time_entries/{WORK_TIME_ENTRIES_ID}DELETE
  if (toolName === "work_time_entries/{WORK_TIME_ENTRIES_ID}DELETE") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/work_time_entries/{WORK_TIME_ENTRIES_ID}";
      const WORK_TIME_ENTRIES_ID_val = validatedArgs['WORK_TIME_ENTRIES_ID'];
      if (typeof WORK_TIME_ENTRIES_ID_val !== 'undefined' && WORK_TIME_ENTRIES_ID_val !== null) { urlPath = urlPath.replace("{WORK_TIME_ENTRIES_ID}", encodeURIComponent(String(WORK_TIME_ENTRIES_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "DELETE",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: work_time_entries/{WORK_TIME_ENTRIES_ID}PATCH
  if (toolName === "work_time_entries/{WORK_TIME_ENTRIES_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/work_time_entries/{WORK_TIME_ENTRIES_ID}";
      const WORK_TIME_ENTRIES_ID_val = validatedArgs['WORK_TIME_ENTRIES_ID'];
      if (typeof WORK_TIME_ENTRIES_ID_val !== 'undefined' && WORK_TIME_ENTRIES_ID_val !== null) { urlPath = urlPath.replace("{WORK_TIME_ENTRIES_ID}", encodeURIComponent(String(WORK_TIME_ENTRIES_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: tasksGET
  if (toolName === "tasksGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tasks";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_tasks_val = validatedArgs['fields[tasks]'];
      if (typeof fields_tasks_val !== 'undefined' && fields_tasks_val !== null) queryParams['fields[tasks]'] = fields_tasks_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const filter_dueDate_gt_val = validatedArgs['filter[dueDate][gt]'];
      if (typeof filter_dueDate_gt_val !== 'undefined' && filter_dueDate_gt_val !== null) queryParams['filter[dueDate][gt]'] = filter_dueDate_gt_val;
      const filter_dueDate_lt_val = validatedArgs['filter[dueDate][lt]'];
      if (typeof filter_dueDate_lt_val !== 'undefined' && filter_dueDate_lt_val !== null) queryParams['filter[dueDate][lt]'] = filter_dueDate_lt_val;
      const filter_dueDate_timezone_val = validatedArgs['filter[dueDate][timezone]'];
      if (typeof filter_dueDate_timezone_val !== 'undefined' && filter_dueDate_timezone_val !== null) queryParams['filter[dueDate][timezone]'] = filter_dueDate_timezone_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const filter_internalProfileId_val = validatedArgs['filter[internalProfileId]'];
      if (typeof filter_internalProfileId_val !== 'undefined' && filter_internalProfileId_val !== null) queryParams['filter[internalProfileId]'] = filter_internalProfileId_val;
      const filter_isCompleted_val = validatedArgs['filter[isCompleted]'];
      if (typeof filter_isCompleted_val !== 'undefined' && filter_isCompleted_val !== null) queryParams['filter[isCompleted]'] = filter_isCompleted_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: tasksPOST
  if (toolName === "tasksPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tasks";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: tasks/{TASK_ID}GET
  if (toolName === "tasks/{TASK_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tasks/{TASK_ID}";
      const TASK_ID_val = validatedArgs['TASK_ID'];
      if (typeof TASK_ID_val !== 'undefined' && TASK_ID_val !== null) { urlPath = urlPath.replace("{TASK_ID}", encodeURIComponent(String(TASK_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: tasks/{TASK_ID}PATCH
  if (toolName === "tasks/{TASK_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/tasks/{TASK_ID}";
      const TASK_ID_val = validatedArgs['TASK_ID'];
      if (typeof TASK_ID_val !== 'undefined' && TASK_ID_val !== null) { urlPath = urlPath.replace("{TASK_ID}", encodeURIComponent(String(TASK_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_daysGET
  if (toolName === "production_daysGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_days";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const filter_workDate_gt_val = validatedArgs['filter[workDate][gt]'];
      if (typeof filter_workDate_gt_val !== 'undefined' && filter_workDate_gt_val !== null) queryParams['filter[workDate][gt]'] = filter_workDate_gt_val;
      const filter_workDate_lt_val = validatedArgs['filter[workDate][lt]'];
      if (typeof filter_workDate_lt_val !== 'undefined' && filter_workDate_lt_val !== null) queryParams['filter[workDate][lt]'] = filter_workDate_lt_val;
      const filter_workDate_timezone_val = validatedArgs['filter[workDate][timezone]'];
      if (typeof filter_workDate_timezone_val !== 'undefined' && filter_workDate_timezone_val !== null) queryParams['filter[workDate][timezone]'] = filter_workDate_timezone_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_daysPOST
  if (toolName === "production_daysPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_days";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_divisions_val = validatedArgs['fields[divisions]'];
      if (typeof fields_divisions_val !== 'undefined' && fields_divisions_val !== null) queryParams['fields[divisions]'] = fields_divisions_val;
      const fields_assignedProductionTaskCategories_val = validatedArgs['fields[assignedProductionTaskCategories]'];
      if (typeof fields_assignedProductionTaskCategories_val !== 'undefined' && fields_assignedProductionTaskCategories_val !== null) queryParams['fields[assignedProductionTaskCategories]'] = fields_assignedProductionTaskCategories_val;
      const fields_productionDays_val = validatedArgs['fields[productionDays]'];
      if (typeof fields_productionDays_val !== 'undefined' && fields_productionDays_val !== null) queryParams['fields[productionDays]'] = fields_productionDays_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_days/{PRODUCTION_DAYS_ID}GET
  if (toolName === "production_days/{PRODUCTION_DAYS_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_days/{PRODUCTION_DAYS_ID}";
      const PRODUCTION_DAYS_ID_val = validatedArgs['PRODUCTION_DAYS_ID'];
      if (typeof PRODUCTION_DAYS_ID_val !== 'undefined' && PRODUCTION_DAYS_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_DAYS_ID}", encodeURIComponent(String(PRODUCTION_DAYS_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_divisions_val = validatedArgs['fields[divisions]'];
      if (typeof fields_divisions_val !== 'undefined' && fields_divisions_val !== null) queryParams['fields[divisions]'] = fields_divisions_val;
      const fields_assignedProductionTaskCategories_val = validatedArgs['fields[assignedProductionTaskCategories]'];
      if (typeof fields_assignedProductionTaskCategories_val !== 'undefined' && fields_assignedProductionTaskCategories_val !== null) queryParams['fields[assignedProductionTaskCategories]'] = fields_assignedProductionTaskCategories_val;
      const fields_productionDays_val = validatedArgs['fields[productionDays]'];
      if (typeof fields_productionDays_val !== 'undefined' && fields_productionDays_val !== null) queryParams['fields[productionDays]'] = fields_productionDays_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_days/{PRODUCTION_DAYS_ID}PATCH
  if (toolName === "production_days/{PRODUCTION_DAYS_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_days/{PRODUCTION_DAYS_ID}";
      const PRODUCTION_DAYS_ID_val = validatedArgs['PRODUCTION_DAYS_ID'];
      if (typeof PRODUCTION_DAYS_ID_val !== 'undefined' && PRODUCTION_DAYS_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_DAYS_ID}", encodeURIComponent(String(PRODUCTION_DAYS_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_divisions_val = validatedArgs['fields[divisions]'];
      if (typeof fields_divisions_val !== 'undefined' && fields_divisions_val !== null) queryParams['fields[divisions]'] = fields_divisions_val;
      const fields_assignedProductionTaskCategories_val = validatedArgs['fields[assignedProductionTaskCategories]'];
      if (typeof fields_assignedProductionTaskCategories_val !== 'undefined' && fields_assignedProductionTaskCategories_val !== null) queryParams['fields[assignedProductionTaskCategories]'] = fields_assignedProductionTaskCategories_val;
      const fields_productionDays_val = validatedArgs['fields[productionDays]'];
      if (typeof fields_productionDays_val !== 'undefined' && fields_productionDays_val !== null) queryParams['fields[productionDays]'] = fields_productionDays_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_itemsGET
  if (toolName === "production_itemsGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_items";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const filter_production_val = validatedArgs['filter[production]'];
      if (typeof filter_production_val !== 'undefined' && filter_production_val !== null) queryParams['filter[production]'] = filter_production_val;
      const filter_productionOnly_val = validatedArgs['filter[productionOnly]'];
      if (typeof filter_productionOnly_val !== 'undefined' && filter_productionOnly_val !== null) queryParams['filter[productionOnly]'] = filter_productionOnly_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const reports_0_val = validatedArgs['reports[0]'];
      if (typeof reports_0_val !== 'undefined' && reports_0_val !== null) queryParams['reports[0]'] = reports_0_val;
      const reports_1_val = validatedArgs['reports[1]'];
      if (typeof reports_1_val !== 'undefined' && reports_1_val !== null) queryParams['reports[1]'] = reports_1_val;
      const reports_2_val = validatedArgs['reports[2]'];
      if (typeof reports_2_val !== 'undefined' && reports_2_val !== null) queryParams['reports[2]'] = reports_2_val;
      const reports_3_val = validatedArgs['reports[3]'];
      if (typeof reports_3_val !== 'undefined' && reports_3_val !== null) queryParams['reports[3]'] = reports_3_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_itemsPOST
  if (toolName === "production_itemsPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_items";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_items/{PRODUCTION_ITEM_ID}GET
  if (toolName === "production_items/{PRODUCTION_ITEM_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_items/{PRODUCTION_ITEM_ID}";
      const PRODUCTION_ITEM_ID_val = validatedArgs['PRODUCTION_ITEM_ID'];
      if (typeof PRODUCTION_ITEM_ID_val !== 'undefined' && PRODUCTION_ITEM_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_ITEM_ID}", encodeURIComponent(String(PRODUCTION_ITEM_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_items/{PRODUCTION_ITEM_ID}PATCH
  if (toolName === "production_items/{PRODUCTION_ITEM_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_items/{PRODUCTION_ITEM_ID}";
      const PRODUCTION_ITEM_ID_val = validatedArgs['PRODUCTION_ITEM_ID'];
      if (typeof PRODUCTION_ITEM_ID_val !== 'undefined' && PRODUCTION_ITEM_ID_val !== null) { urlPath = urlPath.replace("{PRODUCTION_ITEM_ID}", encodeURIComponent(String(PRODUCTION_ITEM_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: budget_typesGET
  if (toolName === "budget_typesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/budget_types";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: budget_typesPOST
  if (toolName === "budget_typesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/budget_types";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: budget_types/{BUDGET_TYPE_ID}GET
  if (toolName === "budget_types/{BUDGET_TYPE_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/budget_types/{BUDGET_TYPE_ID}";
      const BUDGET_TYPE_ID_val = validatedArgs['BUDGET_TYPE_ID'];
      if (typeof BUDGET_TYPE_ID_val !== 'undefined' && BUDGET_TYPE_ID_val !== null) { urlPath = urlPath.replace("{BUDGET_TYPE_ID}", encodeURIComponent(String(BUDGET_TYPE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: budget_types/{BUDGET_TYPE_ID}PATCH
  if (toolName === "budget_types/{BUDGET_TYPE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/budget_types/{BUDGET_TYPE_ID}";
      const BUDGET_TYPE_ID_val = validatedArgs['BUDGET_TYPE_ID'];
      if (typeof BUDGET_TYPE_ID_val !== 'undefined' && BUDGET_TYPE_ID_val !== null) { urlPath = urlPath.replace("{BUDGET_TYPE_ID}", encodeURIComponent(String(BUDGET_TYPE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: budgetGET
  if (toolName === "budgetGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/budget";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const filter_productionId_val = validatedArgs['filter[productionId]'];
      if (typeof filter_productionId_val !== 'undefined' && filter_productionId_val !== null) queryParams['filter[productionId]'] = filter_productionId_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: service_agreementsGET
  if (toolName === "service_agreementsGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/service_agreements";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_buildings_val = validatedArgs['fields[buildings]'];
      if (typeof fields_buildings_val !== 'undefined' && fields_buildings_val !== null) queryParams['fields[buildings]'] = fields_buildings_val;
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const filter_isTerminated_val = validatedArgs['filter[isTerminated]'];
      if (typeof filter_isTerminated_val !== 'undefined' && filter_isTerminated_val !== null) queryParams['filter[isTerminated]'] = filter_isTerminated_val;
      const filter_nextInspectionDate_gt_val = validatedArgs['filter[nextInspectionDate][gt]'];
      if (typeof filter_nextInspectionDate_gt_val !== 'undefined' && filter_nextInspectionDate_gt_val !== null) queryParams['filter[nextInspectionDate][gt]'] = filter_nextInspectionDate_gt_val;
      const filter_nextInspectionDate_lt_val = validatedArgs['filter[nextInspectionDate][lt]'];
      if (typeof filter_nextInspectionDate_lt_val !== 'undefined' && filter_nextInspectionDate_lt_val !== null) queryParams['filter[nextInspectionDate][lt]'] = filter_nextInspectionDate_lt_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const filter_search_val = validatedArgs['filter[search]'];
      if (typeof filter_search_val !== 'undefined' && filter_search_val !== null) queryParams['filter[search]'] = filter_search_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: service_agreementsPOST
  if (toolName === "service_agreementsPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/service_agreements";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: service_agreements/{SERVICE_AGREEMENT_ID}GET
  if (toolName === "service_agreements/{SERVICE_AGREEMENT_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/service_agreements/{SERVICE_AGREEMENT_ID}";
      const SERVICE_AGREEMENT_ID_val = validatedArgs['SERVICE_AGREEMENT_ID'];
      if (typeof SERVICE_AGREEMENT_ID_val !== 'undefined' && SERVICE_AGREEMENT_ID_val !== null) { urlPath = urlPath.replace("{SERVICE_AGREEMENT_ID}", encodeURIComponent(String(SERVICE_AGREEMENT_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: service_agreements/{SERVICE_AGREEMENT_ID}PATCH
  if (toolName === "service_agreements/{SERVICE_AGREEMENT_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/service_agreements/{SERVICE_AGREEMENT_ID}";
      const SERVICE_AGREEMENT_ID_val = validatedArgs['SERVICE_AGREEMENT_ID'];
      if (typeof SERVICE_AGREEMENT_ID_val !== 'undefined' && SERVICE_AGREEMENT_ID_val !== null) { urlPath = urlPath.replace("{SERVICE_AGREEMENT_ID}", encodeURIComponent(String(SERVICE_AGREEMENT_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: productsGET
  if (toolName === "productsGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/products";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_production_val = validatedArgs['fields[production]'];
      if (typeof fields_production_val !== 'undefined' && fields_production_val !== null) queryParams['fields[production]'] = fields_production_val;
      const fields_files_val = validatedArgs['fields[files]'];
      if (typeof fields_files_val !== 'undefined' && fields_files_val !== null) queryParams['fields[files]'] = fields_files_val;
      const fields_products_val = validatedArgs['fields[products]'];
      if (typeof fields_products_val !== 'undefined' && fields_products_val !== null) queryParams['fields[products]'] = fields_products_val;
      const filter_productionId_val = validatedArgs['filter[productionId]'];
      if (typeof filter_productionId_val !== 'undefined' && filter_productionId_val !== null) queryParams['filter[productionId]'] = filter_productionId_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: productsPOST
  if (toolName === "productsPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/products";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_products_val = validatedArgs['fields[products]'];
      if (typeof fields_products_val !== 'undefined' && fields_products_val !== null) queryParams['fields[products]'] = fields_products_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: products/{PRODUCT_ID}GET
  if (toolName === "products/{PRODUCT_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/products/{PRODUCT_ID}";
      const PRODUCT_ID_val = validatedArgs['PRODUCT_ID'];
      if (typeof PRODUCT_ID_val !== 'undefined' && PRODUCT_ID_val !== null) { urlPath = urlPath.replace("{PRODUCT_ID}", encodeURIComponent(String(PRODUCT_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_productions_val = validatedArgs['fields[productions]'];
      if (typeof fields_productions_val !== 'undefined' && fields_productions_val !== null) queryParams['fields[productions]'] = fields_productions_val;
      const fields_products_val = validatedArgs['fields[products]'];
      if (typeof fields_products_val !== 'undefined' && fields_products_val !== null) queryParams['fields[products]'] = fields_products_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: products/{PRODUCT_ID}PATCH
  if (toolName === "products/{PRODUCT_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/products/{PRODUCT_ID}";
      const PRODUCT_ID_val = validatedArgs['PRODUCT_ID'];
      if (typeof PRODUCT_ID_val !== 'undefined' && PRODUCT_ID_val !== null) { urlPath = urlPath.replace("{PRODUCT_ID}", encodeURIComponent(String(PRODUCT_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_products_val = validatedArgs['fields[products]'];
      if (typeof fields_products_val !== 'undefined' && fields_products_val !== null) queryParams['fields[products]'] = fields_products_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: warrantiesGET
  if (toolName === "warrantiesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warranties";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const filter_start_date_gt_val = validatedArgs['filter[start_date][gt]'];
      if (typeof filter_start_date_gt_val !== 'undefined' && filter_start_date_gt_val !== null) queryParams['filter[start_date][gt]'] = filter_start_date_gt_val;
      const filter_start_date_lt_val = validatedArgs['filter[start_date][lt]'];
      if (typeof filter_start_date_lt_val !== 'undefined' && filter_start_date_lt_val !== null) queryParams['filter[start_date][lt]'] = filter_start_date_lt_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const filter_status_0_val = validatedArgs['filter[status][0]'];
      if (typeof filter_status_0_val !== 'undefined' && filter_status_0_val !== null) queryParams['filter[status][0]'] = filter_status_0_val;
      const filter_contractorCompanyId_val = validatedArgs['filter[contractorCompanyId]'];
      if (typeof filter_contractorCompanyId_val !== 'undefined' && filter_contractorCompanyId_val !== null) queryParams['filter[contractorCompanyId]'] = filter_contractorCompanyId_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: warrantiesPOST
  if (toolName === "warrantiesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warranties";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: warranties/{WARRANTY_ID}GET
  if (toolName === "warranties/{WARRANTY_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warranties/{WARRANTY_ID}";
      const WARRANTY_ID_val = validatedArgs['WARRANTY_ID'];
      if (typeof WARRANTY_ID_val !== 'undefined' && WARRANTY_ID_val !== null) { urlPath = urlPath.replace("{WARRANTY_ID}", encodeURIComponent(String(WARRANTY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: warranties/{WARRANTY_ID}PATCH
  if (toolName === "warranties/{WARRANTY_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/warranties/{WARRANTY_ID}";
      const WARRANTY_ID_val = validatedArgs['WARRANTY_ID'];
      if (typeof WARRANTY_ID_val !== 'undefined' && WARRANTY_ID_val !== null) { urlPath = urlPath.replace("{WARRANTY_ID}", encodeURIComponent(String(WARRANTY_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_companies_val = validatedArgs['fields[companies]'];
      if (typeof fields_companies_val !== 'undefined' && fields_companies_val !== null) queryParams['fields[companies]'] = fields_companies_val;
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: buildings/{BUILDING_ID}GET
  if (toolName === "buildings/{BUILDING_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/buildings/{BUILDING_ID}";
      const BUILDING_ID_val = validatedArgs['BUILDING_ID'];
      if (typeof BUILDING_ID_val !== 'undefined' && BUILDING_ID_val !== null) { urlPath = urlPath.replace("{BUILDING_ID}", encodeURIComponent(String(BUILDING_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_properties_val = validatedArgs['fields[properties]'];
      if (typeof fields_properties_val !== 'undefined' && fields_properties_val !== null) queryParams['fields[properties]'] = fields_properties_val;
      const fields_buildings_val = validatedArgs['fields[buildings]'];
      if (typeof fields_buildings_val !== 'undefined' && fields_buildings_val !== null) queryParams['fields[buildings]'] = fields_buildings_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_outlinesPOST
  if (toolName === "building_outlinesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_outlines";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_outlines/{BUILDING_OUTLINES_ID}GET
  if (toolName === "building_outlines/{BUILDING_OUTLINES_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_outlines/{BUILDING_OUTLINES_ID}";
      const BUILDING_OUTLINES_ID_val = validatedArgs['BUILDING_OUTLINES_ID'];
      if (typeof BUILDING_OUTLINES_ID_val !== 'undefined' && BUILDING_OUTLINES_ID_val !== null) { urlPath = urlPath.replace("{BUILDING_OUTLINES_ID}", encodeURIComponent(String(BUILDING_OUTLINES_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_outlines/{BUILDING_OUTLINES_ID}PATCH
  if (toolName === "building_outlines/{BUILDING_OUTLINES_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_outlines/{BUILDING_OUTLINES_ID}";
      const BUILDING_OUTLINES_ID_val = validatedArgs['BUILDING_OUTLINES_ID'];
      if (typeof BUILDING_OUTLINES_ID_val !== 'undefined' && BUILDING_OUTLINES_ID_val !== null) { urlPath = urlPath.replace("{BUILDING_OUTLINES_ID}", encodeURIComponent(String(BUILDING_OUTLINES_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_divisionsPOST
  if (toolName === "building_divisionsPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_divisions";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_divisions/{BUILDING_DIVISIONS_ID}GET
  if (toolName === "building_divisions/{BUILDING_DIVISIONS_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_divisions/{BUILDING_DIVISIONS_ID}";
      const BUILDING_DIVISIONS_ID_val = validatedArgs['BUILDING_DIVISIONS_ID'];
      if (typeof BUILDING_DIVISIONS_ID_val !== 'undefined' && BUILDING_DIVISIONS_ID_val !== null) { urlPath = urlPath.replace("{BUILDING_DIVISIONS_ID}", encodeURIComponent(String(BUILDING_DIVISIONS_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_products_val = validatedArgs['fields[products]'];
      if (typeof fields_products_val !== 'undefined' && fields_products_val !== null) queryParams['fields[products]'] = fields_products_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_divisions/{BUILDING_DIVISIONS_ID}PATCH
  if (toolName === "building_divisions/{BUILDING_DIVISIONS_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_divisions/{BUILDING_DIVISIONS_ID}";
      const BUILDING_DIVISIONS_ID_val = validatedArgs['BUILDING_DIVISIONS_ID'];
      if (typeof BUILDING_DIVISIONS_ID_val !== 'undefined' && BUILDING_DIVISIONS_ID_val !== null) { urlPath = urlPath.replace("{BUILDING_DIVISIONS_ID}", encodeURIComponent(String(BUILDING_DIVISIONS_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: product_template_tagsGET
  if (toolName === "product_template_tagsGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/product_template_tags";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_photosPOST
  if (toolName === "building_photosPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_photos";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_photos/{BUILDING_PHOTO_ID}GET
  if (toolName === "building_photos/{BUILDING_PHOTO_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_photos/{BUILDING_PHOTO_ID}";
      const BUILDING_PHOTO_ID_val = validatedArgs['BUILDING_PHOTO_ID'];
      if (typeof BUILDING_PHOTO_ID_val !== 'undefined' && BUILDING_PHOTO_ID_val !== null) { urlPath = urlPath.replace("{BUILDING_PHOTO_ID}", encodeURIComponent(String(BUILDING_PHOTO_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_photos/{BUILDING_PHOTO_ID}PATCH
  if (toolName === "building_photos/{BUILDING_PHOTO_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_photos/{BUILDING_PHOTO_ID}";
      const BUILDING_PHOTO_ID_val = validatedArgs['BUILDING_PHOTO_ID'];
      if (typeof BUILDING_PHOTO_ID_val !== 'undefined' && BUILDING_PHOTO_ID_val !== null) { urlPath = urlPath.replace("{BUILDING_PHOTO_ID}", encodeURIComponent(String(BUILDING_PHOTO_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: production_stage_transitionsPOST
  if (toolName === "production_stage_transitionsPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/production_stage_transitions";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_scoresPOST
  if (toolName === "building_scoresPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_scores";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: building_scores/{BUILDING_SCORE_ID}PATCH
  if (toolName === "building_scores/{BUILDING_SCORE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/building_scores/{BUILDING_SCORE_ID}";
      const BUILDING_SCORE_ID_val = validatedArgs['BUILDING_SCORE_ID'];
      if (typeof BUILDING_SCORE_ID_val !== 'undefined' && BUILDING_SCORE_ID_val !== null) { urlPath = urlPath.replace("{BUILDING_SCORE_ID}", encodeURIComponent(String(BUILDING_SCORE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: filesGET
  if (toolName === "filesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/files";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: files/{FILE_ID}GET
  if (toolName === "files/{FILE_ID}GET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/files/{FILE_ID}";
      const FILE_ID_val = validatedArgs['FILE_ID'];
      if (typeof FILE_ID_val !== 'undefined' && FILE_ID_val !== null) { urlPath = urlPath.replace("{FILE_ID}", encodeURIComponent(String(FILE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: files/{FILE_ID}PATCH
  if (toolName === "files/{FILE_ID}PATCH") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/files/{FILE_ID}";
      const FILE_ID_val = validatedArgs['FILE_ID'];
      if (typeof FILE_ID_val !== 'undefined' && FILE_ID_val !== null) { urlPath = urlPath.replace("{FILE_ID}", encodeURIComponent(String(FILE_ID_val))); }
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "PATCH",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: filesPOST
  if (toolName === "filesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/file/url";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: modelFilesGET
  if (toolName === "modelFilesGET") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/model_files";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};
      const fields_profiles_val = validatedArgs['fields[profiles]'];
      if (typeof fields_profiles_val !== 'undefined' && fields_profiles_val !== null) queryParams['fields[profiles]'] = fields_profiles_val;
      const fields_employees_val = validatedArgs['fields[employees]'];
      if (typeof fields_employees_val !== 'undefined' && fields_employees_val !== null) queryParams['fields[employees]'] = fields_employees_val;
      const fields_buildingDivisions_val = validatedArgs['fields[buildingDivisions]'];
      if (typeof fields_buildingDivisions_val !== 'undefined' && fields_buildingDivisions_val !== null) queryParams['fields[buildingDivisions]'] = fields_buildingDivisions_val;
      const filter_tag_val = validatedArgs['filter[tag]'];
      if (typeof filter_tag_val !== 'undefined' && filter_tag_val !== null) queryParams['filter[tag]'] = filter_tag_val;
      const filter_subjectId_val = validatedArgs['filter[subjectId]'];
      if (typeof filter_subjectId_val !== 'undefined' && filter_subjectId_val !== null) queryParams['filter[subjectId]'] = filter_subjectId_val;
      const filter_subjectType_val = validatedArgs['filter[subjectType]'];
      if (typeof filter_subjectType_val !== 'undefined' && filter_subjectType_val !== null) queryParams['filter[subjectType]'] = filter_subjectType_val;
      const filter_updated_at_gt_val = validatedArgs['filter[updated_at][gt]'];
      if (typeof filter_updated_at_gt_val !== 'undefined' && filter_updated_at_gt_val !== null) queryParams['filter[updated_at][gt]'] = filter_updated_at_gt_val;
      const filter_updated_at_lt_val = validatedArgs['filter[updated_at][lt]'];
      if (typeof filter_updated_at_lt_val !== 'undefined' && filter_updated_at_lt_val !== null) queryParams['filter[updated_at][lt]'] = filter_updated_at_lt_val;
      const include_val = validatedArgs['include'];
      if (typeof include_val !== 'undefined' && include_val !== null) queryParams['include'] = include_val;
      const page_size_val = validatedArgs['page[size]'];
      if (typeof page_size_val !== 'undefined' && page_size_val !== null) queryParams['page[size]'] = page_size_val;
      const page_number_val = validatedArgs['page[number]'];
      if (typeof page_number_val !== 'undefined' && page_number_val !== null) queryParams['page[number]'] = page_number_val;
      const sort_val = validatedArgs['sort'];
      if (typeof sort_val !== 'undefined' && sort_val !== null) queryParams['sort'] = sort_val;

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);

 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "GET",
        url: requestUrl,
        params: queryParams,
        headers: headers,
         // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: actionsPOST
  if (toolName === "actionsPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/actions";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: notesPOST
  if (toolName === "notesPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/notes";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } else 
  // Handler for tool: transactionsPOST
  if (toolName === "transactionsPOST") {
    try {

      // --- Argument Validation using Zod ---
      let validatedArgs: JsonObject;
      try {
          const zodSchema = getZodSchemaFromJsonSchema(toolDefinition.inputSchema, toolName);
          const argsToParse = (typeof toolArgs === 'object' && toolArgs !== null) ? toolArgs : {};
          validatedArgs = zodSchema.parse(argsToParse);
          console.error(`Arguments validated successfully for tool '${toolName}'.`);
      } catch (error: any) {
          if (error instanceof ZodError) {
              const validationErrorMessage = `Invalid arguments for tool '${toolName}': ${error.errors.map(e => `${e.path.join('.')} (${e.code}): ${e.message}`).join(', ')}`;
              console.error(validationErrorMessage);
              return { content: [{ type: 'text', text: validationErrorMessage }] };
          } else {
               console.error(`Unexpected error during argument validation setup for tool '${toolName}':`, error);
               return { content: [{ type: 'text', text: `Internal server error during argument validation setup for tool '${toolName}'.` }] };
          }
      }
      // --- End Argument Validation ---

      // --- API Call Preparation ---
      let urlPath = "/transactions";
      if (urlPath.includes('{')) { throw new Error(`Validation passed but failed to resolve path parameters in URL: ${urlPath}. Check schema/validation logic.`); }
      const requestUrl = API_BASE_URL ? `${API_BASE_URL}${urlPath}` : urlPath;
      const queryParams: Record<string, any> = {};

      const headers: Record<string, string> = { 'Accept': 'application/json' };
      const Authorization_val = validatedArgs['Authorization'];
      if (typeof Authorization_val !== 'undefined' && Authorization_val !== null) headers['authorization'] = String(Authorization_val);
      // Set Content-Type based on OpenAPI spec (or fallback)
      if (typeof validatedArgs?.['requestBody'] !== 'undefined') { headers['content-type'] = 'application/json'; }

      let requestBodyData: any = undefined;
      if (validatedArgs && typeof validatedArgs['requestBody'] !== 'undefined') {
          requestBodyData = validatedArgs['requestBody'];
      }
 // Declare and assign requestBodyData *here*

      // --- Authentication Logic ---
      try {
        const authToken = validatedArgs["Authorization"];
        const authHeader = createAuthenticatedHeaders(authToken);
        Object.assign(headers, authHeader);
      } catch (error: any) {
        console.error(`Authentication error for tool '${toolName}'':`, error.message);
        return { content: [{ type: "text", text: error.message }] };
      }

      // --- Axios Request Configuration ---
      // Now 'requestBodyData' is declared before being referenced here
      const config: AxiosRequestConfig = {
        method: "POST",
        url: requestUrl,
        params: queryParams,
        headers: headers,
        data: requestBodyData, // Pass the prepared request body data // Include data property conditionally
      };

      console.error(`Executing tool "${toolName}": ${config.method} ${config.url}`);

      // --- Execute API Call ---
      const response = await axios(config);

      // --- Process Successful Response ---
      let responseText = '';
      const contentType = response.headers['content-type']?.toLowerCase() || '';
      if (contentType.includes('application/json') && typeof response.data === 'object' && response.data !== null) {
           try { responseText = JSON.stringify(response.data, null, 2); }
           catch (e) { responseText = "[Error: Failed to stringify JSON response]"; }
      } else if (typeof response.data === 'string') {
           responseText = response.data;
      } else if (response.data !== undefined && response.data !== null) {
           responseText = String(response.data);
      } else {
           responseText = `(Status: ${response.status} - No body content)`;
      }
      return { content: [ { type: "text", text: `API Response (Status: ${response.status}):\n${responseText}` } ], };

    } catch (error: any) {
      // --- Handle Errors (Post-Validation) ---
      let errorMessage = `Error executing tool '${toolName}': ${error.message}`;
      if (axios.isAxiosError(error)) { errorMessage = formatApiError(error); }
      else if (error instanceof Error) { errorMessage = error.message; }
      else { errorMessage = 'An unexpected error occurred: ' + String(error); }
      console.error(`Error during execution of tool '${toolName}':`, errorMessage, error.stack);
      return { content: [{ type: "text", text: errorMessage }] };
    }
  } // This generated code now includes Zod validation

  // Fallback error
  console.error(`Error: Handler logic missing for tool: ${toolName}. This indicates an issue in the generator.`);
  return { content: [{ type: "text", text: `Error: Internal server error - handler not implemented for tool: ${toolName}` }] };
});


// --- Main Execution Function ---
async function main() {
  try {
    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error(`${SERVER_NAME} MCP Server (v${SERVER_VERSION}) running on stdio${API_BASE_URL ? `, proxying API at ${API_BASE_URL}` : ''}`);
  } catch (error) {
    console.error("Error during server startup:", error);
    process.exit(1);
  }
}

// --- Cleanup Function ---
async function cleanup() {
    console.error("Shutting down MCP server...");
    process.exit(0);
}

// Register signal handlers
process.on('SIGINT', cleanup);
process.on('SIGTERM', cleanup);

// --- Start the Server ---
main().catch((error) => {
  console.error("Fatal error in main execution:", error);
  process.exit(1);
});

// --- Helper Functions (Included in the generated server code) ---
function formatApiError(error: AxiosError): string {
    let message = 'API request failed.';
    if (error.response) {
        message = `API Error: Status ${error.response.status} (${error.response.statusText || 'Status text not available'}). `;
        const responseData = error.response.data;
        const MAX_LEN = 200;
        if (typeof responseData === 'string') {
            message += `Response: ${responseData.substring(0, MAX_LEN)}${responseData.length > MAX_LEN ? '...' : ''}`;
        } else if (responseData) {
            try {
                const jsonString = JSON.stringify(responseData);
                message += `Response: ${jsonString.substring(0, MAX_LEN)}${jsonString.length > MAX_LEN ? '...' : ''}`;
            } catch {
                message += 'Response: [Could not serialize response data]';
            }
        } else {
            message += 'No response body received.';
        }
    } else if (error.request) {
        message = 'API Network Error: No response received from the server. Check network connectivity or server availability.';
        if (error.code) message += ` (Code: ${error.code})`;
    } else {
        message = `API Request Setup Error: ${error.message}`;
    }
    return message;
}

/**
 * Attempts to dynamically generate and evaluate a Zod schema from a JSON schema.
 * WARNING: Uses eval(), which can be a security risk if the schema input is untrusted.
 * In this context, the schema originates from the generator/OpenAPI spec, reducing risk.
 * @param jsonSchema The JSON Schema object (or boolean).
 * @param toolName For error logging.
 * @returns The evaluated Zod schema object.
 * @throws If schema conversion or evaluation fails.
 */
function getZodSchemaFromJsonSchema(jsonSchema: any, toolName: string): z.ZodTypeAny {
    if (typeof jsonSchema !== 'object' || jsonSchema === null) {
        // Handle boolean schemas or invalid input
        console.warn(`Cannot generate Zod schema for non-object JSON schema for tool '${toolName}'. Input type: ${typeof jsonSchema}`)
        // Fallback to allowing any object - adjust if stricter handling is needed
        return z.object({}).passthrough();
    }
    try {
        // Note: jsonSchemaToZod may require specific configurations or adjustments
        // depending on the complexity of the JSON Schemas being converted.
        const zodSchemaString = jsonSchemaToZod(jsonSchema);

        // IMPORTANT: Using eval() to execute the generated Zod schema string.
        // This is generally discouraged due to security risks with untrusted input.
        // Ensure the JSON schemas processed here are from trusted sources (like your OpenAPI spec).
        // The 'z' variable (from imported zod) must be in scope for eval.
        const zodSchema = eval(zodSchemaString);

        if (typeof zodSchema?.parse !== 'function') {
             throw new Error('Generated Zod schema string did not evaluate to a valid Zod schema object.');
        }
        return zodSchema as z.ZodTypeAny;
    } catch (err: any) {
        console.error(`Failed to generate or evaluate Zod schema for tool '${toolName}':`, err);
        // Fallback schema in case of conversion/evaluation error
        // This allows any object, effectively skipping validation on error.
        // Consider throwing the error if validation is critical.
        return z.object({}).passthrough();
    }
}
